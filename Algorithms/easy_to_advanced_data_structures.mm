<map version="1.0.1">
<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->
<node CREATED="1567047499480" ID="ID_848879358" MODIFIED="1567047509773" TEXT="Easy to Advanced Data Structures">
<node CREATED="1567047519719" ID="ID_1870705705" MODIFIED="1567047546195" POSITION="right" TEXT="Introduction">
<node CREATED="1567047547072" ID="ID_1482133181" MODIFIED="1567047556583" TEXT="Abstract data types Introduction">
<node CREATED="1567048146445" ID="ID_1527261415" MODIFIED="1567048151762" TEXT="Foundation of core concepts">
<node CREATED="1567048155289" ID="ID_1604713066" MODIFIED="1567048160996" TEXT="What is a Data Structure?">
<node CREATED="1567048161861" ID="ID_972709341" MODIFIED="1567048176522" TEXT="A data structure (DS) is a way of organizing data so that it can be used effectively">
<node CREATED="1567048176965" ID="ID_1760679641" MODIFIED="1567048192405" TEXT="Accessed, queried, updated quickly and easily"/>
</node>
</node>
<node CREATED="1567048196116" ID="ID_584157180" MODIFIED="1567048202869" TEXT="Why Data Structures?">
<node CREATED="1567048203081" ID="ID_1519000817" MODIFIED="1567048219734" TEXT="They are essential ingredients in constructing fast and powerful algorithms"/>
<node CREATED="1567048221883" ID="ID_1327740219" MODIFIED="1567048227994" TEXT="They help to manage and organize data">
<node CREATED="1567048251110" ID="ID_99980391" MODIFIED="1567048254493" TEXT="Natural way"/>
</node>
<node CREATED="1567048228829" ID="ID_1061542262" MODIFIED="1567048241121" TEXT="They make code cleaner and easier to understand">
<node CREATED="1567048266443" ID="ID_553087727" MODIFIED="1567048268513" TEXT="Side note">
<node CREATED="1567048271696" ID="ID_13629465" MODIFIED="1567048293870" TEXT="Good programmers know how and when to use which data structure">
<node CREATED="1567048297325" ID="ID_1870009713" MODIFIED="1567048336806" TEXT="Good data structure makes a distinction between mediocre product and outstanding product"/>
</node>
</node>
</node>
</node>
<node CREATED="1567048340253" ID="ID_1330546745" MODIFIED="1567048354017" TEXT="Abstract Data Types vs. Data Structures">
<node CREATED="1567048354444" ID="ID_1368365896" MODIFIED="1567048358830" TEXT="Abstract Data Type">
<node CREATED="1567049971952" ID="ID_1969241598" MODIFIED="1567050003576" TEXT="An abstract data type (ADT) is an abstraction of a data structure which provides only the interface to which a data structure must adhere to.">
<node CREATED="1567050068116" ID="ID_768531720" MODIFIED="1567050084249" TEXT="Example: ADT - mode of transportation from A to B">
<node CREATED="1567050086125" ID="ID_808806907" MODIFIED="1567050089933" TEXT="Walking">
<node CREATED="1567050105182" ID="ID_1810617131" MODIFIED="1567050112116" TEXT="analogy of DS"/>
</node>
<node CREATED="1567050090159" ID="ID_971404041" MODIFIED="1567050091748" TEXT="Biking">
<node CREATED="1567050101606" ID="ID_739859823" MODIFIED="1567050104294" TEXT="analogy of DS"/>
</node>
<node CREATED="1567050092053" ID="ID_354990631" MODIFIED="1567050094949" TEXT="Taking train">
<node CREATED="1567050095868" ID="ID_1379385249" MODIFIED="1567050100269" TEXT="analogy of DS"/>
</node>
</node>
<node CREATED="1567050376371" ID="ID_548337334" MODIFIED="1567050387992" TEXT="Defines only how a DS should behave and what methods should it have"/>
</node>
<node CREATED="1567050003840" ID="ID_446587686" MODIFIED="1567050032495" TEXT="The interface does not give any specific details about how something should be implemented or in what programming language."/>
<node CREATED="1567050120813" ID="ID_1290676435" MODIFIED="1567050122382" TEXT="Examples">
<node CREATED="1567050122748" ID="ID_1045354089" MODIFIED="1567050126702" TEXT="ADT">
<node CREATED="1567050134121" ID="ID_760062472" MODIFIED="1567050135590" TEXT="List"/>
<node CREATED="1567050136611" ID="ID_253734829" MODIFIED="1567050137542" TEXT="Queue"/>
<node CREATED="1567050138375" ID="ID_294273149" MODIFIED="1567050139085" TEXT="Map"/>
<node CREATED="1567050139706" ID="ID_171491451" MODIFIED="1567050142997" TEXT="Vehicle"/>
</node>
<node CREATED="1567050128059" ID="ID_446856430" MODIFIED="1567050132190" TEXT="Implementation (DS)">
<node CREATED="1567050144814" ID="ID_1475189516" MODIFIED="1567050154894" TEXT="List">
<node CREATED="1567050155402" ID="ID_860803046" MODIFIED="1567050158814" TEXT="Dynamic Array"/>
<node CREATED="1567050159020" ID="ID_472897415" MODIFIED="1567050161398" TEXT="Linked List"/>
</node>
<node CREATED="1567050162268" ID="ID_67161090" MODIFIED="1567050164839" TEXT="Queue">
<node CREATED="1567050165122" ID="ID_1810256365" MODIFIED="1567050171286" TEXT="Linked List based Queue"/>
<node CREATED="1567050171932" ID="ID_1177733064" MODIFIED="1567050175718" TEXT="Array based Queue"/>
<node CREATED="1567050176060" ID="ID_1952779168" MODIFIED="1567050180198" TEXT="Stack based Queue">
<node CREATED="1567050359923" ID="ID_961338755" MODIFIED="1567050366194" TEXT="Not very efficient but possible"/>
</node>
</node>
<node CREATED="1567050181613" ID="ID_1793641982" MODIFIED="1567050183093" TEXT="Map">
<node CREATED="1567050183462" ID="ID_1365477796" MODIFIED="1567050185959" TEXT="Tree Map"/>
<node CREATED="1567050186191" ID="ID_1801598759" MODIFIED="1567050194088" TEXT="Hash Map/ Hash Table"/>
</node>
<node CREATED="1567050195239" ID="ID_1360024543" MODIFIED="1567050197247" TEXT="Vehicle">
<node CREATED="1567050197523" ID="ID_603547195" MODIFIED="1567050200999" TEXT="Golf Cart"/>
<node CREATED="1567050201237" ID="ID_691978505" MODIFIED="1567050203646" TEXT="Bicycle"/>
<node CREATED="1567050203888" ID="ID_4544758" MODIFIED="1567050207198" TEXT="Smart Car"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047558304" ID="ID_1539145981" MODIFIED="1567047567049" TEXT="Understanding time/space complexity">
<node CREATED="1567050583744" ID="ID_634634" MODIFIED="1567050602140" TEXT="Used to understand the performance of the DSs"/>
<node CREATED="1567050606281" ID="ID_346096629" MODIFIED="1567050610864" TEXT="Complexity Analysis">
<node CREATED="1567050611192" ID="ID_978437048" MODIFIED="1567050631057" TEXT="As programmers, we often find ourselves asking the same two questions over and over agian:">
<node CREATED="1567050634553" ID="ID_1708263559" MODIFIED="1567050669401">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      How much <b>time</b>&#160;does this algorithm need to finish?
    </p>
  </body>
</html></richcontent>
<font NAME="SansSerif" SIZE="12"/>
<node CREATED="1567050733584" ID="ID_932859777" MODIFIED="1567050739412" TEXT="Extreme case">
<node CREATED="1567050739618" ID="ID_362957" MODIFIED="1567050756496" TEXT="If program takes lifetime of universe to finish then it is bad"/>
</node>
</node>
<node CREATED="1567050673178" ID="ID_1178122761" MODIFIED="1567050702733">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      How much <b>space</b>&#160;does this algorithm need for its computation?
    </p>
  </body>
</html></richcontent>
<node CREATED="1567050765766" ID="ID_1025606052" MODIFIED="1567050768525" TEXT="Extreme case">
<node CREATED="1567050768725" ID="ID_1218753379" MODIFIED="1567050785870" TEXT="If program data takes all the bytes in all the files in the internet then it is bad"/>
</node>
</node>
</node>
<node CREATED="1567050799455" ID="ID_712791161" MODIFIED="1567050803550" TEXT="Big-O Notation">
<node CREATED="1567050807911" ID="ID_806542766" MODIFIED="1567050837545" TEXT="Big-O Notation gives an upper bound of the complexity in the worst case, helping to quantify performance as the input size becomes ararbitrarily large.">
<node CREATED="1567050910294" ID="ID_1532968674" MODIFIED="1567050918417" TEXT="It tells us the worst case">
<node CREATED="1567050924052" ID="ID_965193666" MODIFIED="1567050928423" TEXT="Example: Sorting">
<node CREATED="1567050928698" ID="ID_676568122" MODIFIED="1567050937460" TEXT="Assume input is the worst possible arrangement"/>
</node>
<node CREATED="1567050947540" ID="ID_1767353782" MODIFIED="1567050955080" TEXT="Exampe: Un-ordered list of numbers">
<node CREATED="1567050955343" ID="ID_584022651" MODIFIED="1567050962191" TEXT="Search for a number">
<node CREATED="1567050962535" ID="ID_1902306706" MODIFIED="1567050969583" TEXT="If number is last element or does not exist">
<node CREATED="1567050973886" ID="ID_1662335772" MODIFIED="1567050975880" TEXT="O(n)">
<node CREATED="1567050977582" ID="ID_1984585657" MODIFIED="1567050982960" TEXT="Need to traverse every element"/>
</node>
</node>
</node>
</node>
<node CREATED="1567050991761" ID="ID_909361956" MODIFIED="1567050994007" TEXT="Space">
<node CREATED="1567050994394" ID="ID_35974909" MODIFIED="1567051010757" TEXT="Worst amount of space possible"/>
</node>
</node>
<node CREATED="1567051022092" ID="ID_14313874" MODIFIED="1567051038713" TEXT="It tells how does the algorithm perform when the input is arbitrarily large">
<node CREATED="1567051038997" ID="ID_1622314018" MODIFIED="1567051047923" TEXT="Or grows to be arbitrarliy large"/>
<node CREATED="1567051057206" ID="ID_1230805795" MODIFIED="1567051065795" TEXT="We need to ignore constants and multiplicative factors"/>
</node>
<node CREATED="1567052115202" ID="ID_531484791" MODIFIED="1567052118690" TEXT="Big-O Notation">
<node CREATED="1567052118961" ID="ID_1355543050" MODIFIED="1567052132942" TEXT="n - The size of the input"/>
<node CREATED="1567052133184" ID="ID_1593801299" MODIFIED="1567052146005" TEXT="Compexities ordered in from smallest to largest">
<node CREATED="1567052146758" ID="ID_381616594" MODIFIED="1567052150821" TEXT="Constant Time: O(1)"/>
<node CREATED="1567052151250" ID="ID_607809622" MODIFIED="1567052158476" TEXT="Logarithmic Time: O(log(n))"/>
<node CREATED="1567052158995" ID="ID_543677270" MODIFIED="1567052163828" TEXT="Linear Time: O(n)"/>
<node CREATED="1567052164107" ID="ID_846709647" MODIFIED="1567052173734" TEXT="Linearithmic Time: O(nlog(n))"/>
<node CREATED="1567052174346" ID="ID_25020748" MODIFIED="1567052181765" TEXT="Quadratic Time: O(n^2)"/>
<node CREATED="1567052182091" ID="ID_1538719926" MODIFIED="1567052189318" TEXT="Cubic Time: O(n^3)"/>
<node CREATED="1567052189572" ID="ID_795812748" MODIFIED="1567052200939" TEXT="Exponential Time: O(b^n), b &gt; 1"/>
<node CREATED="1567052201302" ID="ID_1716108746" MODIFIED="1567052208222" TEXT="Factorial Time: O(n!)"/>
</node>
<node CREATED="1567483342098" ID="ID_506727581" MODIFIED="1567483345986" TEXT="Big-O Properties">
<node CREATED="1567483347275" ID="ID_1661548267" MODIFIED="1567483352859" TEXT="O(n + c) = O(n)">
<node CREATED="1567483508645" ID="ID_1680707201" MODIFIED="1567483519194" TEXT="adding c to infinity it is infinity"/>
</node>
<node CREATED="1567483357175" ID="ID_1737777107" MODIFIED="1567483366028" TEXT="O(cn) = O(n), c &gt; 0">
<node CREATED="1567483521283" ID="ID_439513698" MODIFIED="1567483536549" TEXT="multiplying by c to infinity is infinity"/>
</node>
</node>
<node CREATED="1567483384611" ID="ID_1355655522" MODIFIED="1567483388292" TEXT="Big-O Example">
<node CREATED="1567483388532" ID="ID_1512523692" MODIFIED="1567483407604" TEXT="Let f be a function that describes the running time of a particular algorithm for an input of size n:">
<node CREATED="1567483407929" ID="ID_1986830200" MODIFIED="1567483428430" TEXT="f(n) = 7log(n)^3 + 15n^2 + 2n^3 + 8">
<node CREATED="1567483429113" ID="ID_122976438" MODIFIED="1567483436757" TEXT="O(f(n)) = O(n^3)"/>
</node>
</node>
</node>
<node CREATED="1567483469454" ID="ID_715997094" MODIFIED="1567483480241" TEXT="We are only interested in what happens when n tends to infinity"/>
<node CREATED="1567483569081" ID="ID_1386628664" MODIFIED="1567483570577" TEXT="Examples">
<node CREATED="1567483570831" ID="ID_1783177980" MODIFIED="1567483620147">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      a := 1
    </p>
    <p>
      b := 2
    </p>
    <p>
      c := a + 5 * b
    </p>
    <p>
      
    </p>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; 11 Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483622032" ID="ID_1489138490" MODIFIED="1567483624555" TEXT="O(1)">
<node CREATED="1567483625320" ID="ID_966436955" MODIFIED="1567483629394" TEXT="Does not depend on n"/>
</node>
</node>
<node CREATED="1567483638428" ID="ID_1879236817" MODIFIED="1567483702462">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
    <p>
      
    </p>
    <p>
      f(n) = n
    </p>
    <p>
      O(f(n)) = O(n)
    </p>
    <p>
      
    </p>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 3
    </p>
    <p>
      
    </p>
    <p>
      f(n) = n/3
    </p>
    <p>
      O(f(n)) = O(n)
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1567483751485" ID="ID_517940471" MODIFIED="1567483781346" TEXT="Both of the following run in quadratic time. The first may be obvious since n work done n times is n * n = O(n^2), but what about hte second one?">
<node CREATED="1567483781691" ID="ID_1437914013" MODIFIED="1567483815840">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      For (i := 0; i &lt; n; i = i + 1)
    </p>
    <p>
      &#160;&#160;&#160;&#160;For (j := 0; j &lt; n; j = j + 1)
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483816908" ID="ID_367307686" MODIFIED="1567483833128" TEXT="f(n) = n * n = n^2, O(f(n)) = O(n^2)"/>
</node>
<node CREATED="1567483835704" ID="ID_1029876442" MODIFIED="1567483867606">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      For (i := 0; i &lt; n; i = i + 1)
    </p>
    <p>
      &#160;&#160;&#160;&#160;For (j := i; j &lt; n; j = j + 1)
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483868738" ID="ID_1698382569" MODIFIED="1567483879882" TEXT="f(n) = n * (n + 1) / 2 = O(n^2)">
<node CREATED="1567483945779" ID="ID_176704251" MODIFIED="1567483957976" TEXT="n + n - 1 + n - 2 + ... + 2 + 1"/>
</node>
</node>
</node>
<node CREATED="1567483967627" ID="ID_199317909" MODIFIED="1567483992833" TEXT="Suppose we have a sorted array and we want to find the index of a particular value in the array, if it existss. What is the time complexity of the following algorithm?">
<node CREATED="1567483996872" ID="ID_350440965" MODIFIED="1567484076382">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      low := 0
    </p>
    <p>
      high := n - 1
    </p>
    <p>
      While low &lt;= high Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;mid := (low + high) / 2
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;If array[mid] == value: return mid
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else If array[mid] &lt; value: lo = mid + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else if array[mid] &gt; value: hi = mid - 1
    </p>
    <p>
      
    </p>
    <p>
      return -1 // Value not found
    </p>
  </body>
</html></richcontent>
<node CREATED="1567739365040" ID="ID_918302151" MODIFIED="1567739378222" TEXT="O(log_2(n)) = O(log(n))"/>
</node>
</node>
<node CREATED="1567739388910" ID="ID_802167150" MODIFIED="1567739440079">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; 3 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; 2 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567740156422" ID="ID_115184184" MODIFIED="1567740181698" TEXT="f(n) = n(3 * n + 2 * n)">
<node CREATED="1567740182676" ID="ID_1272501794" MODIFIED="1567740187971" TEXT="5n^2">
<node CREATED="1567740188723" ID="ID_1071984168" MODIFIED="1567740192243" TEXT="O(n^2)"/>
</node>
</node>
<node CREATED="1567740208040" ID="ID_505467184" MODIFIED="1567740218959" TEXT="Usually we multiply loops to understand the complexity"/>
</node>
<node CREATED="1567740386348" ID="ID_1644365420" MODIFIED="1567740447875">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; 3 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;j := 10
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt;= 50 Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; n * n * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 2
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567740469664" ID="ID_1964911772" MODIFIED="1567740516504" TEXT="3n(40 + n^3 / 2)">
<node CREATED="1567740516967" ID="ID_1730363809" MODIFIED="1567740532763" TEXT="120n + 3/2 n^4">
<node CREATED="1567740533537" ID="ID_1552370744" MODIFIED="1567740536243" TEXT="O(n^4)"/>
</node>
</node>
</node>
</node>
<node CREATED="1567740663162" ID="ID_719426810" MODIFIED="1567740673401" TEXT="Classic algorithms">
<node CREATED="1567740677239" ID="ID_1505914170" MODIFIED="1567740684114" TEXT="Finding all subsets of a set">
<node CREATED="1567740684385" ID="ID_1747181382" MODIFIED="1567740697154" TEXT="O(2^n)"/>
</node>
<node CREATED="1567740700792" ID="ID_4910673" MODIFIED="1567740707281" TEXT="Finding all permutations of a string">
<node CREATED="1567740711999" ID="ID_1080694945" MODIFIED="1567740714790" TEXT="O(n!)"/>
</node>
<node CREATED="1567740715783" ID="ID_993495177" MODIFIED="1567740723287" TEXT="Sorting using mergesort">
<node CREATED="1567740723680" ID="ID_619216783" MODIFIED="1567740734601" TEXT="O(nlog(n))"/>
</node>
<node CREATED="1567740735671" ID="ID_274602272" MODIFIED="1567740748601" TEXT="Iterating over all the cells in a matrix of size n by m">
<node CREATED="1567740749100" ID="ID_1221718477" MODIFIED="1567740751369" TEXT="O(nm)"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047528993" ID="ID_1399730678" MODIFIED="1567047577626" POSITION="left" TEXT="Static and dynamic arrays">
<node CREATED="1567047581826" ID="ID_1451464606" MODIFIED="1567047587379" TEXT="Static and dynamic arrays">
<node CREATED="1567740969214" ID="ID_891909700" MODIFIED="1567740986912" TEXT="It is a fundamental building block for all other data structures">
<node CREATED="1567741001708" ID="ID_402506270" MODIFIED="1567741023847" TEXT="With arrays and pointers, we can pretty much construct most of the other data structures"/>
</node>
<node CREATED="1567742283054" ID="ID_1012995521" MODIFIED="1567742285829" TEXT="Outline">
<node CREATED="1567742288074" ID="ID_1682683025" MODIFIED="1567742294779" TEXT="Discussion and examples about Arrays">
<node CREATED="1567743038338" ID="ID_541205340" MODIFIED="1567743042218" TEXT="What is an Array?">
<node CREATED="1567743215862" ID="ID_60098891" MODIFIED="1567743220554" TEXT="What is a static Array?">
<node CREATED="1567743223564" ID="ID_282012604" MODIFIED="1567743325256" TEXT="it is a fixed length container containing n elementss indexable from the range [0, n-1]]">
<node CREATED="1567743347888" ID="ID_1033098623" MODIFIED="1567743355733" TEXT="What is meant by being &apos;indesable&apos;?">
<node CREATED="1567743363014" ID="ID_1508750640" MODIFIED="1567743378119" TEXT="Each slock/index in the array can be referenced with a number"/>
<node CREATED="1567743570768" ID="ID_128896455" MODIFIED="1567743583660" TEXT="static array&apos;s are contiguous">
<node CREATED="1567743584199" ID="ID_1696497962" MODIFIED="1567743590648" TEXT="all the addresses are adjacent"/>
</node>
<node CREATED="1567743595064" ID="ID_250048985" MODIFIED="1567743601907" TEXT="When and where is a static Array used?">
<node CREATED="1567743604729" ID="ID_265349520" MODIFIED="1567743613218" TEXT="Storing and accessing sequential data"/>
<node CREATED="1567743613784" ID="ID_958677039" MODIFIED="1567743619441" TEXT="Temporarily storing objects"/>
<node CREATED="1567743619653" ID="ID_1231884551" MODIFIED="1567743633732" TEXT="Used by IO routines as buffers">
<node CREATED="1567744097508" ID="ID_105571827" MODIFIED="1567744108098" TEXT="small chunks are read into buffer"/>
</node>
<node CREATED="1567743635300" ID="ID_189133681" MODIFIED="1567743641672" TEXT="Lookup tables and inverse lookup tables"/>
<node CREATED="1567743660827" ID="ID_513605889" MODIFIED="1567743670561" TEXT="Can be used to return multiple values from a function"/>
<node CREATED="1567743677389" ID="ID_1399756762" MODIFIED="1567743692751" TEXT="Used in dynamic programming to cache answers to subproblems">
<node CREATED="1567744163727" ID="ID_1297602780" MODIFIED="1567744166302" TEXT="knapsack"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567743042735" ID="ID_1889701925" MODIFIED="1567743051502" TEXT="When and where is Array used?"/>
<node CREATED="1567743052743" ID="ID_809712671" MODIFIED="1567743054761" TEXT="Complexity">
<node CREATED="1567744182855" ID="ID_334982288" MODIFIED="1567744196270" TEXT="Static array">
<node CREATED="1567744196708" ID="ID_262077195" MODIFIED="1567744199798" TEXT="Access">
<node CREATED="1567744216132" ID="ID_1972610693" MODIFIED="1567744217646" TEXT="O(1)"/>
</node>
<node CREATED="1567744220956" ID="ID_1165848702" MODIFIED="1567744222310" TEXT="Search">
<node CREATED="1567744224511" ID="ID_1921765869" MODIFIED="1567744226014" TEXT="O(n)"/>
</node>
<node CREATED="1567744238447" ID="ID_285228148" MODIFIED="1567744240567" TEXT="Insertion">
<node CREATED="1567744241636" ID="ID_570212304" MODIFIED="1567744245735" TEXT="N/A"/>
</node>
<node CREATED="1567744262110" ID="ID_296613237" MODIFIED="1567744263527" TEXT="Appending">
<node CREATED="1567744263856" ID="ID_1328649856" MODIFIED="1567744265256" TEXT="N/A"/>
</node>
<node CREATED="1567744274481" ID="ID_1178520383" MODIFIED="1567744276512" TEXT="Deletion">
<node CREATED="1567744276799" ID="ID_941271524" MODIFIED="1567744277856" TEXT="N/A"/>
</node>
</node>
<node CREATED="1567744203732" ID="ID_30653370" MODIFIED="1567744207142" TEXT="Dynamic array">
<node CREATED="1567744208007" ID="ID_241189416" MODIFIED="1567744211486" TEXT="Access">
<node CREATED="1567744212620" ID="ID_722521109" MODIFIED="1567744214158" TEXT="O(1)"/>
</node>
<node CREATED="1567744228483" ID="ID_922961325" MODIFIED="1567744230046" TEXT="Search">
<node CREATED="1567744230436" ID="ID_425857956" MODIFIED="1567744232463" TEXT="O(n)"/>
</node>
<node CREATED="1567744248504" ID="ID_1442482277" MODIFIED="1567744250055" TEXT="Insertion">
<node CREATED="1567744250493" ID="ID_979607167" MODIFIED="1567744251847" TEXT="O(n)">
<node CREATED="1567744366243" ID="ID_1928402019" MODIFIED="1567744378835" TEXT="Need to shift all the elements to the right (worst case)">
<node CREATED="1567744381028" ID="ID_425834286" MODIFIED="1567744386316" TEXT="Assumption">
<node CREATED="1567744386609" ID="ID_242421637" MODIFIED="1567744392979" TEXT="Implementing dynamic array using static array"/>
</node>
</node>
</node>
</node>
<node CREATED="1567744266717" ID="ID_1106006380" MODIFIED="1567744268047" TEXT="Appending">
<node CREATED="1567744268260" ID="ID_1847058056" MODIFIED="1567744270087" TEXT="O(1)">
<node CREATED="1567744494375" ID="ID_1849886656" MODIFIED="1567744509445" TEXT="Need to resize but amortized cost is constant"/>
</node>
</node>
<node CREATED="1567744279540" ID="ID_1659958774" MODIFIED="1567744283896" TEXT="Deletion">
<node CREATED="1567744284104" ID="ID_881689456" MODIFIED="1567744285448" TEXT="O(n)">
<node CREATED="1567744512157" ID="ID_936562656" MODIFIED="1567744522757" TEXT="Need to shift all the elements to the right"/>
</node>
</node>
</node>
</node>
<node CREATED="1567743057067" ID="ID_1990103355" MODIFIED="1567743061985" TEXT="Static array usage example">
<node CREATED="1567820192174" ID="ID_1542035116" MODIFIED="1567820244806">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Elements in A are referenced by their index.
    </p>
    <p>
      There is no other way to access elements in an array.
    </p>
    <p>
      Array indexing is zero-based, meaning the first element is found in position zero.
    </p>
  </body>
</html></richcontent>
<node CREATED="1567820338883" ID="ID_29717769" MODIFIED="1567820347986" TEXT="Quntum Computing">
<node CREATED="1567820350610" ID="ID_404335549" MODIFIED="1567820355290" TEXT="indexing doesn&apos;t work well"/>
</node>
</node>
</node>
</node>
<node CREATED="1567743071768" ID="ID_395567913" MODIFIED="1567743080002" TEXT="Dynamic Array implementation details">
<node CREATED="1567743202507" ID="ID_1847691529" MODIFIED="1567743207017" TEXT="Using only static array"/>
<node CREATED="1567820436944" ID="ID_145700277" MODIFIED="1567820442681" TEXT="Dynamic Array">
<node CREATED="1567820446312" ID="ID_1819139855" MODIFIED="1567820454849" TEXT="Can grow and shrink in size">
<node CREATED="1567820459307" ID="ID_159438728" MODIFIED="1567820463369" TEXT="A.add(-7)"/>
<node CREATED="1567820467756" ID="ID_396155446" MODIFIED="1567820472148" TEXT="A.add(34)"/>
<node CREATED="1567820472851" ID="ID_1838616854" MODIFIED="1567820476301" TEXT="A.remove(4)"/>
</node>
<node CREATED="1567820514481" ID="ID_1950396911" MODIFIED="1567820523691" TEXT="How can we implement a dynamic array?">
<node CREATED="1567820524076" ID="ID_444368617" MODIFIED="1567820532813" TEXT="One way is to use a static array">
<node CREATED="1567820537018" ID="ID_1642198053" MODIFIED="1567820546752" TEXT="Construct a static array with an initial capacity"/>
<node CREATED="1567820547165" ID="ID_1130028197" MODIFIED="1567820564437" TEXT="Add elements to the underlying static array, keeping track of the number of elements"/>
<node CREATED="1567820564661" ID="ID_1999783764" MODIFIED="1567820588396" TEXT="If adding another element will exceed the capacity, then construct a new static array with twice the capacity and copy the original elements into it">
<node CREATED="1567820950685" ID="ID_87292204" MODIFIED="1567820959165" TEXT="Implement dyamic array using generics">
<node CREATED="1567821143544" ID="ID_1340604753" MODIFIED="1567821147938" TEXT="Implement Iterator"/>
<node CREATED="1567821148470" ID="ID_1877391349" MODIFIED="1567821155291" TEXT="Implement toString()"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567743081898" ID="ID_1673304816" MODIFIED="1567743085196" TEXT="Code Implementation"/>
</node>
</node>
<node CREATED="1567047588529" ID="ID_1239959045" MODIFIED="1567047594145" TEXT="Dynamic array source code"/>
</node>
<node CREATED="1567047597595" ID="ID_1783641617" MODIFIED="1567047604763" POSITION="right" TEXT="Linked lists">
<node CREATED="1567047608399" ID="ID_1422994141" MODIFIED="1567047614545" TEXT="Linked list introduction">
<node CREATED="1567833120599" ID="ID_976775126" MODIFIED="1567833123249" TEXT="Outline">
<node CREATED="1567833123633" ID="ID_1729536421" MODIFIED="1567833135081" TEXT="Discussion about Singly &amp; Doubly Linked Lists">
<node CREATED="1567833135729" ID="ID_1366817558" MODIFIED="1567833141521" TEXT="What is a linked list?">
<node CREATED="1567833970993" ID="ID_1795758471" MODIFIED="1567833976747" TEXT="Singly and Doubly Linked Lists"/>
<node CREATED="1567834027206" ID="ID_1355595821" MODIFIED="1567834066737" TEXT="A liked list is a sequential list of nodes that hold data which point to other nodes also containing data.">
<node CREATED="1567834079284" ID="ID_462711654" MODIFIED="1567834091990" TEXT="Every node has a pointer to next node"/>
<node CREATED="1567834092698" ID="ID_1697236078" MODIFIED="1567834097692" TEXT="Last node has null reference"/>
</node>
</node>
<node CREATED="1567833141769" ID="ID_388690781" MODIFIED="1567833148230" TEXT="Where are linked lists used?">
<node CREATED="1567834459445" ID="ID_1329287514" MODIFIED="1567834469714" TEXT="Used in many List, Queue &amp; Stack implementations"/>
<node CREATED="1567834471745" ID="ID_1241012632" MODIFIED="1567834479224" TEXT="Great for constructing circular lists">
<node CREATED="1567834550017" ID="ID_359877582" MODIFIED="1567834558778" TEXT="pointer of last node is pointing to first node"/>
<node CREATED="1567834561649" ID="ID_225662096" MODIFIED="1567834569371" TEXT="Round robbin scheduling"/>
</node>
<node CREATED="1567834479472" ID="ID_623874626" MODIFIED="1567834489927" TEXT="Can easily model real world objects such as trains"/>
<node CREATED="1567834490160" ID="ID_145618758" MODIFIED="1567834512840" TEXT="Used in separate chaining, which is present certain Hashtable implementations to deal with hashing collisions"/>
<node CREATED="1567834514768" ID="ID_1618861595" MODIFIED="1567834525659" TEXT="Often used in the implementation of adjacency lists for graphs"/>
</node>
<node CREATED="1567833148455" ID="ID_967352583" MODIFIED="1567833151528" TEXT="Terminology">
<node CREATED="1567834599921" ID="ID_950423457" MODIFIED="1567834601524" TEXT="Head">
<node CREATED="1567834602621" ID="ID_1648984151" MODIFIED="1567834607076" TEXT="first node in a linked list">
<node CREATED="1567834607308" ID="ID_1279551557" MODIFIED="1567834612008" TEXT="always need to maintain this"/>
</node>
</node>
<node CREATED="1567853453437" ID="ID_1875776916" MODIFIED="1567853454487" TEXT="Tail">
<node CREATED="1567853454806" ID="ID_1814523700" MODIFIED="1567853462343" TEXT="last node in a linked list"/>
</node>
<node CREATED="1567853465088" ID="ID_781963862" MODIFIED="1567853468839" TEXT="Pointer">
<node CREATED="1567853469156" ID="ID_1538542627" MODIFIED="1567853476286" TEXT="reference to another node"/>
</node>
<node CREATED="1567853477239" ID="ID_156367923" MODIFIED="1567853478663" TEXT="Node">
<node CREATED="1567853479141" ID="ID_217982775" MODIFIED="1567853488493" TEXT="object containing data and pointer(s)"/>
</node>
</node>
<node CREATED="1567833151759" ID="ID_169836061" MODIFIED="1567833160377" TEXT="Singly Linked vs. Doubly Linked">
<node CREATED="1567864996558" ID="ID_1104303525" MODIFIED="1567865051806" TEXT="Singly linked lists only hold a reference to the next node. In the implementation you always maintain a reference to the head to the linked list and a reference to the tail node for quick additions/ removals."/>
<node CREATED="1567865055371" ID="ID_978648675" MODIFIED="1567865123988" TEXT="With a doubly linked list each node holds a reference to the next and previous node. In the implementation you always maintain a reference to the head and the tail of the doubly linked list to do quick additions/removals from both ends of your list."/>
<node CREATED="1567865310771" ID="ID_346037168" MODIFIED="1567865313974" TEXT="Pros">
<node CREATED="1567865320391" ID="ID_1667514471" MODIFIED="1567865352343" TEXT="Singly linked list">
<node CREATED="1567865326459" ID="ID_63764172" MODIFIED="1567865332350" TEXT="uses less(er) memory"/>
<node CREATED="1567865333976" ID="ID_777245891" MODIFIED="1567865340446" TEXT="simpler implementation"/>
</node>
<node CREATED="1567865341216" ID="ID_976989408" MODIFIED="1567865345847" TEXT="Doubly linked list">
<node CREATED="1567865362178" ID="ID_1080365259" MODIFIED="1567865366901" TEXT="can be traversed backwards"/>
<node CREATED="1567865472012" ID="ID_840852753" MODIFIED="1567865478986" TEXT="we can remove a node in constant time">
<node CREATED="1567865489762" ID="ID_181798720" MODIFIED="1567865509013" TEXT="needs reference to previous node">
<node CREATED="1567865515862" ID="ID_1457513154" MODIFIED="1567865517093" TEXT="easy"/>
</node>
</node>
</node>
</node>
<node CREATED="1567865314206" ID="ID_1876370493" MODIFIED="1567865317110" TEXT="Cons">
<node CREATED="1567865371197" ID="ID_975406318" MODIFIED="1567865383642" TEXT="cannot easily access previous elements"/>
<node CREATED="1567865384795" ID="ID_1992008723" MODIFIED="1567865390397" TEXT="takes 2x memory">
<node CREATED="1567865409828" ID="ID_1946301276" MODIFIED="1567865418307" TEXT="on a 64 bit machine">
<node CREATED="1567865418508" ID="ID_89154144" MODIFIED="1567865423980" TEXT="references take 8 bytes"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567833162559" ID="ID_1624272856" MODIFIED="1567833166761" TEXT="Implementation Details">
<node CREATED="1567833166984" ID="ID_277366498" MODIFIED="1567833171679" TEXT="How to insert new elements">
<node CREATED="1567866354284" ID="ID_1038091725" MODIFIED="1567866477772">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      newNode.data &lt;- 11
    </p>
    <p>
      newNode.next &lt;- trav.next
    </p>
    <p>
      trav.next &lt;- newNode
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1567866498968" ID="ID_11541807" MODIFIED="1567866503726" TEXT="doubly linked list">
<node CREATED="1567866505064" ID="ID_845284105" MODIFIED="1567866588130">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      newNode.data &lt;- 11
    </p>
    <p>
      newNode.next &lt;- pos
    </p>
    <p>
      newNode.prev &lt;- trav
    </p>
    <p>
      pos.prev &lt;- newNode
    </p>
    <p>
      trav.nex &lt;- newNode
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567833171882" ID="ID_1690375808" MODIFIED="1567833177159" TEXT="How to remove elements">
<node CREATED="1567866604842" ID="ID_553375484" MODIFIED="1567866609322" TEXT="singly linked list">
<node CREATED="1567866610465" ID="ID_875555249" MODIFIED="1567866624974" TEXT="using two pointers">
<node CREATED="1567866630230" ID="ID_1259552629" MODIFIED="1567866733700">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav1 &lt;- head
    </p>
    <p>
      trav2 &lt;- head.next
    </p>
    <p>
      trav2 &lt;- trav2.next
    </p>
    <p>
      trav1 &lt;- trav1.next
    </p>
    <p>
      ...
    </p>
    <p>
      temp &lt;- trav2
    </p>
    <p>
      trav2 &lt;- trav2.next
    </p>
    <p>
      trav1.next &lt;- trav2
    </p>
    <p>
      remove temp
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567866736098" ID="ID_1514077046" MODIFIED="1567866739173" TEXT="doubly linked list">
<node CREATED="1567866779586" ID="ID_420048895" MODIFIED="1567866782770" TEXT="use single pointer">
<node CREATED="1567866783035" ID="ID_1844735609" MODIFIED="1567866851591">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      trav.prev.next &lt;- trav.next
    </p>
    <p>
      trav.next.prev &lt;- trav.prev
    </p>
    <p>
      remove trav
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567833179097" ID="ID_186455063" MODIFIED="1567833184058" TEXT="Complexity analysis">
<node CREATED="1567866873482" ID="ID_1853046036" MODIFIED="1567866878531" TEXT="singly linked list">
<node CREATED="1567866882502" ID="ID_330483936" MODIFIED="1567866885811" TEXT="search">
<node CREATED="1567866885972" ID="ID_517357335" MODIFIED="1567866887548" TEXT="O(n)"/>
</node>
<node CREATED="1567866890835" ID="ID_415155634" MODIFIED="1567866894892" TEXT="insert at head">
<node CREATED="1567866895123" ID="ID_96923319" MODIFIED="1567866897404" TEXT="O(1)"/>
</node>
<node CREATED="1567866905109" ID="ID_942875541" MODIFIED="1567866908884" TEXT="insert at tail">
<node CREATED="1567866909225" ID="ID_1015240473" MODIFIED="1567866911148" TEXT="O(1)"/>
</node>
<node CREATED="1567866981105" ID="ID_1833748317" MODIFIED="1567866984052" TEXT="remove at head">
<node CREATED="1567866984475" ID="ID_322332530" MODIFIED="1567866985772" TEXT="O(1)"/>
</node>
<node CREATED="1567866986938" ID="ID_1908370664" MODIFIED="1567866989804" TEXT="remove at tail">
<node CREATED="1567866993125" ID="ID_605897530" MODIFIED="1567866994484" TEXT="O(n)">
<node CREATED="1567867059287" ID="ID_958713840" MODIFIED="1567867069671" TEXT="tail needs to be reset"/>
</node>
</node>
<node CREATED="1567867001596" ID="ID_1081718839" MODIFIED="1567867004599" TEXT="remove in middle">
<node CREATED="1567867005238" ID="ID_1144151002" MODIFIED="1567867006399" TEXT="O(n)"/>
</node>
</node>
<node CREATED="1567866878954" ID="ID_1277221017" MODIFIED="1567866881762" TEXT="doubly linked list">
<node CREATED="1567866915970" ID="ID_1608402570" MODIFIED="1567866917525" TEXT="search">
<node CREATED="1567866917838" ID="ID_1086368704" MODIFIED="1567866922101" TEXT="O(n)"/>
</node>
<node CREATED="1567866924268" ID="ID_996696552" MODIFIED="1567866926573" TEXT="insert at head">
<node CREATED="1567866926761" ID="ID_853601712" MODIFIED="1567866928301" TEXT="O(1)"/>
</node>
<node CREATED="1567866929241" ID="ID_760740272" MODIFIED="1567866931893" TEXT="insert at tail">
<node CREATED="1567866932102" ID="ID_259382152" MODIFIED="1567866933533" TEXT="O(1)"/>
</node>
<node CREATED="1567867009975" ID="ID_427065675" MODIFIED="1567867011991" TEXT="remove at head">
<node CREATED="1567867012232" ID="ID_1280011565" MODIFIED="1567867013839" TEXT="O(1)"/>
</node>
<node CREATED="1567867014699" ID="ID_287686875" MODIFIED="1567867017286" TEXT="remove at tail">
<node CREATED="1567867017558" ID="ID_1089434193" MODIFIED="1567867018950" TEXT="O(1)"/>
</node>
<node CREATED="1567867019712" ID="ID_1874375030" MODIFIED="1567867022463" TEXT="remove in middle">
<node CREATED="1567867022757" ID="ID_1847715946" MODIFIED="1567867024263" TEXT="O(n)"/>
</node>
</node>
</node>
<node CREATED="1567833185111" ID="ID_833463333" MODIFIED="1567833189354" TEXT="Code Implementation">
<node CREATED="1567833189622" ID="ID_1257981521" MODIFIED="1567833193218" TEXT="Double Linked List">
<node CREATED="1567867203141" ID="ID_514488670" MODIFIED="1567867216631" TEXT="implement Iterable"/>
<node CREATED="1567867216889" ID="ID_555973994" MODIFIED="1567867220082" TEXT="Use generics"/>
<node CREATED="1567867226670" ID="ID_614584917" MODIFIED="1567867233610" TEXT="Define Node class"/>
<node CREATED="1567867246974" ID="ID_1126895755" MODIFIED="1567867254493" TEXT="operations">
<node CREATED="1567867257030" ID="ID_1706268935" MODIFIED="1567867258925" TEXT="toString"/>
<node CREATED="1567867259174" ID="ID_1362674625" MODIFIED="1567867261909" TEXT="clear"/>
<node CREATED="1567867264206" ID="ID_900226026" MODIFIED="1567867264871" TEXT="size"/>
<node CREATED="1567867266567" ID="ID_977142376" MODIFIED="1567867268485" TEXT="isEmpty"/>
<node CREATED="1567867291319" ID="ID_295176672" MODIFIED="1567867292288" TEXT="add"/>
<node CREATED="1567867293415" ID="ID_1042489593" MODIFIED="1567867294971" TEXT="addFirst"/>
<node CREATED="1567867303058" ID="ID_1587794680" MODIFIED="1567867305012" TEXT="addLast"/>
<node CREATED="1567867379119" ID="ID_815004841" MODIFIED="1567867382205" TEXT="peekFirst">
<node CREATED="1567867394796" ID="ID_1378199614" MODIFIED="1567867399213" TEXT="throw RuntimeException"/>
</node>
<node CREATED="1567867383812" ID="ID_835721909" MODIFIED="1567867385869" TEXT="peekLast"/>
<node CREATED="1567867387670" ID="ID_147300986" MODIFIED="1567867393420" TEXT="removeFirst"/>
<node CREATED="1567867463139" ID="ID_918055018" MODIFIED="1567867464347" TEXT="remove">
<node CREATED="1567867525303" ID="ID_853949203" MODIFIED="1567867528961" TEXT="return data"/>
</node>
<node CREATED="1567867531254" ID="ID_1335903396" MODIFIED="1567867532921" TEXT="removeAt">
<node CREATED="1567867534712" ID="ID_93504921" MODIFIED="1567867535641" TEXT="index">
<node CREATED="1567867573590" ID="ID_655246484" MODIFIED="1567867582157" TEXT="if closer to front, traverse from front"/>
</node>
</node>
<node CREATED="1567867584412" ID="ID_551074386" MODIFIED="1567867586708" TEXT="remove">
<node CREATED="1567867586946" ID="ID_817453311" MODIFIED="1567867588269" TEXT="object"/>
</node>
<node CREATED="1567867629858" ID="ID_1173421391" MODIFIED="1567867632305" TEXT="indexOf">
<node CREATED="1567867633830" ID="ID_1467810903" MODIFIED="1567867634902" TEXT="object">
<node CREATED="1567867650344" ID="ID_1124720010" MODIFIED="1567867658490" TEXT="if object is null, return the index"/>
</node>
</node>
<node CREATED="1567867662025" ID="ID_1552933879" MODIFIED="1567867663489" TEXT="contains">
<node CREATED="1567867669837" ID="ID_953521111" MODIFIED="1567867672436" TEXT="use indexOf"/>
</node>
<node CREATED="1567867676693" ID="ID_232629674" MODIFIED="1567867681779" TEXT="iterator">
<node CREATED="1567867702797" ID="ID_231782192" MODIFIED="1567867709748" TEXT="concurrent modification can be checked"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047616342" ID="ID_26747835" MODIFIED="1567047622360" TEXT="Doubly linked list source code"/>
</node>
<node CREATED="1567047624020" ID="ID_1851544901" MODIFIED="1567047628840" POSITION="left" TEXT="Stacks">
<node CREATED="1567047630177" ID="ID_354936170" MODIFIED="1567047633887" TEXT="Understanding stacks">
<node CREATED="1567867779650" ID="ID_1632968457" MODIFIED="1567867780985" TEXT="Outline">
<node CREATED="1567867784542" ID="ID_51889379" MODIFIED="1567867790522" TEXT="Discussion about Stacks">
<node CREATED="1567867791446" ID="ID_983885774" MODIFIED="1567867795089" TEXT="What is a Stack?">
<node CREATED="1567868294662" ID="ID_1890646272" MODIFIED="1567868320063" TEXT="A stack is a one-ended linear data structure which models a real world stack by having two primary operations, namely push and pop">
<node CREATED="1567868343781" ID="ID_546308158" MODIFIED="1567868345578" TEXT="top">
<node CREATED="1567868345815" ID="ID_153481245" MODIFIED="1567868347059" TEXT="pointer"/>
</node>
<node CREATED="1567868352394" ID="ID_1927693508" MODIFIED="1567868354370" TEXT="LIFO"/>
</node>
<node CREATED="1567868369852" ID="ID_1274139999" MODIFIED="1567868371207" TEXT="example">
<node CREATED="1567868371463" ID="ID_1887709427" MODIFIED="1567868374542" TEXT="instructions">
<node CREATED="1567868375087" ID="ID_561895132" MODIFIED="1567868422788">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      pop()
    </p>
    <p>
      push('Onion')
    </p>
    <p>
      push('Celery')
    </p>
    <p>
      push('Watermelon')
    </p>
    <p>
      pop()
    </p>
    <p>
      pop()
    </p>
    <p>
      push('Lettuce')
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1567867795355" ID="ID_403562840" MODIFIED="1567867803544" TEXT="When and where is a Stack used?">
<node CREATED="1567868441473" ID="ID_1893010171" MODIFIED="1567868453889" TEXT="Used by undo mechanism in text editors"/>
<node CREATED="1567868455818" ID="ID_773428452" MODIFIED="1567868470763" TEXT="Used in compiler syntax checking for matching brackets and braces"/>
<node CREATED="1567868471923" ID="ID_916567027" MODIFIED="1567868480875" TEXT="Can be used to model a pile of books or plates"/>
<node CREATED="1567868481086" ID="ID_1127383903" MODIFIED="1567868498941" TEXT="Used behind the scenes to support recursion by keeping track of previous function calls"/>
<node CREATED="1567868499348" ID="ID_464979143" MODIFIED="1567868511507" TEXT="Can be used to do a Depth First Search (DFS) on a graph"/>
<node CREATED="1567868545707" ID="ID_700327659" MODIFIED="1567868546901" TEXT="games">
<node CREATED="1567868547158" ID="ID_934977752" MODIFIED="1567868549685" TEXT="tower of hannoi"/>
</node>
</node>
<node CREATED="1567867803733" ID="ID_682283518" MODIFIED="1567867810106" TEXT="Complexity Analysis">
<node CREATED="1567868587005" ID="ID_35146974" MODIFIED="1567868589982" TEXT="push">
<node CREATED="1567868591095" ID="ID_1175170519" MODIFIED="1567868592327" TEXT="O(1)"/>
</node>
<node CREATED="1567868593173" ID="ID_447474788" MODIFIED="1567868594623" TEXT="pop()">
<node CREATED="1567868594851" ID="ID_1930600313" MODIFIED="1567868596463" TEXT="O(1)"/>
</node>
<node CREATED="1567868597291" ID="ID_1271883920" MODIFIED="1567868599431" TEXT="peek()">
<node CREATED="1567868599695" ID="ID_783731951" MODIFIED="1567868601871" TEXT="O(1)"/>
</node>
<node CREATED="1567868603240" ID="ID_503190249" MODIFIED="1567868605671" TEXT="search()">
<node CREATED="1567868606848" ID="ID_1369803216" MODIFIED="1567868608927" TEXT="O(n)">
<node CREATED="1567868651442" ID="ID_1503672373" MODIFIED="1567868656841" TEXT="need to scan from the top"/>
</node>
</node>
<node CREATED="1567868610128" ID="ID_1887850831" MODIFIED="1567868612255" TEXT="size()">
<node CREATED="1567868614161" ID="ID_328879783" MODIFIED="1567868618944" TEXT="O(1)"/>
</node>
</node>
<node CREATED="1567867810514" ID="ID_1220707808" MODIFIED="1567867815706" TEXT="Stack usage examples">
<node CREATED="1567868661843" ID="ID_1495474462" MODIFIED="1567868669181" TEXT="problem">
<node CREATED="1567868669362" ID="ID_227988786" MODIFIED="1567868697704" TEXT="Given a string made up of the following brackets: ()[]{}, determine whether the brackets properly match">
<node CREATED="1567868720738" ID="ID_382126135" MODIFIED="1567868739949" TEXT="Current Bracket, Reversed Bracket">
<node CREATED="1567868741941" ID="ID_1706006058" MODIFIED="1567868744956" TEXT="Track them"/>
</node>
<node CREATED="1567868919754" ID="ID_632329927" MODIFIED="1567868923524" TEXT="pseudocode">
<node CREATED="1567868924190" ID="ID_1475681509" MODIFIED="1567868999805">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Let S be a stack
    </p>
    <p>
      For bracket in bracket_string:
    </p>
    <p>
      &#160;&#160;&#160;&#160;rev = getReversedBracket(bracket)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;If isLeftBracket(bracket):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S.push(bracket)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else If S.isEmpty() or S.pop() != rev:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false // Invalid
    </p>
    <p>
      
    </p>
    <p>
      return S.isEmpty() // Valid if S is empty
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1567869088715" ID="ID_1503374573" MODIFIED="1567869093679" TEXT="tower of hanoi">
<node CREATED="1567869162784" ID="ID_755206345" MODIFIED="1567869176614" TEXT="can be implemented using push() and pop() operations"/>
</node>
</node>
</node>
<node CREATED="1567867819291" ID="ID_1184774594" MODIFIED="1567867823650" TEXT="Implementation details">
<node CREATED="1567867823891" ID="ID_1934476443" MODIFIED="1567867829649" TEXT="Pushing elements on stack"/>
<node CREATED="1567867829993" ID="ID_1410298915" MODIFIED="1567867836156" TEXT="Popping elements from stack"/>
</node>
<node CREATED="1567867837785" ID="ID_6120644" MODIFIED="1567867843139" TEXT="Code Implementation">
<node CREATED="1567869235477" ID="ID_678381324" MODIFIED="1567869238696" TEXT="singly linked list">
<node CREATED="1567869245706" ID="ID_1447832879" MODIFIED="1567869250635" TEXT="Head &lt;- null"/>
<node CREATED="1567869261115" ID="ID_1372982234" MODIFIED="1567869265976" TEXT="push()">
<node CREATED="1567869266325" ID="ID_70783602" MODIFIED="1567869275405" TEXT="insert before the head()"/>
</node>
<node CREATED="1567869307691" ID="ID_1286155703" MODIFIED="1567869310250" TEXT="pop()">
<node CREATED="1567873757452" ID="ID_904660103" MODIFIED="1567873759715" TEXT="Java">
<node CREATED="1567873759984" ID="ID_282262814" MODIFIED="1567873766050" TEXT="assign to null"/>
</node>
<node CREATED="1567873770760" ID="ID_257148189" MODIFIED="1567873772570" TEXT="C/C++">
<node CREATED="1567873772809" ID="ID_946344979" MODIFIED="1567873779026" TEXT="free/delete"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567868280836" ID="ID_216925841" MODIFIED="1567868282942" TEXT="Discussion"/>
</node>
<node CREATED="1567047634990" ID="ID_1954637024" MODIFIED="1567047640557" TEXT="Stack implementation details"/>
<node CREATED="1567047642263" ID="ID_1870968557" MODIFIED="1567047645764" TEXT="Stack source code">
<node CREATED="1567874546458" ID="ID_1087737339" MODIFIED="1567874548840" TEXT="operations">
<node CREATED="1567874549066" ID="ID_814970242" MODIFIED="1567874552722" TEXT="isEmpty"/>
<node CREATED="1567874553785" ID="ID_1705551405" MODIFIED="1567874554776" TEXT="push"/>
<node CREATED="1567874555010" ID="ID_128960302" MODIFIED="1567874556275" TEXT="pop"/>
<node CREATED="1567874556752" ID="ID_463079582" MODIFIED="1567874557784" TEXT="peek"/>
<node CREATED="1567874587478" ID="ID_683268280" MODIFIED="1567874590074" TEXT="iterator"/>
</node>
</node>
</node>
<node CREATED="1567047647640" ID="ID_758481653" MODIFIED="1567047652152" POSITION="right" TEXT="Queues">
<node CREATED="1567047654280" ID="ID_686273722" MODIFIED="1567047658504" TEXT="Understanding queues">
<node CREATED="1567875181348" ID="ID_240456656" MODIFIED="1567875182964" TEXT="Outline">
<node CREATED="1567875183170" ID="ID_274061719" MODIFIED="1567875188522" TEXT="Discussion About Queues">
<node CREATED="1567875189932" ID="ID_207525459" MODIFIED="1567875193475" TEXT="What is a queue?">
<node CREATED="1567875340296" ID="ID_1930591323" MODIFIED="1567875367369" TEXT="A queue is a linear data structure which models real world queues by having two primary operations, namely enqueue and dequeue"/>
</node>
<node CREATED="1567875193689" ID="ID_1313118671" MODIFIED="1567875196908" TEXT="Terminology">
<node CREATED="1567875393844" ID="ID_375265685" MODIFIED="1567875397332" TEXT="Queue Front">
<node CREATED="1567875401045" ID="ID_1460939009" MODIFIED="1567875405356" TEXT="Used to dequeue"/>
</node>
<node CREATED="1567875397545" ID="ID_764050732" MODIFIED="1567875399836" TEXT="Queue Back">
<node CREATED="1567875406224" ID="ID_1783712288" MODIFIED="1567875412100" TEXT="Used to enqueue"/>
</node>
<node CREATED="1567875430132" ID="ID_1226262060" MODIFIED="1567875454055" TEXT="There does not seem to be a consistent terminology for inserting and removing elements from queues">
<node CREATED="1567875455522" ID="ID_1196420610" MODIFIED="1567875461483" TEXT="Enqueue = Adding = Offering"/>
<node CREATED="1567875956848" ID="ID_1689657762" MODIFIED="1567875961066" TEXT="Dequeue = Polling">
<node CREATED="1567875969080" ID="ID_1392341799" MODIFIED="1567875974658" TEXT="removing (another term)"/>
</node>
</node>
<node CREATED="1567876017738" ID="ID_1108660989" MODIFIED="1567876019260" TEXT="Example"/>
</node>
<node CREATED="1567875197120" ID="ID_25662673" MODIFIED="1567875246762" TEXT="When and where is queue used?">
<node CREATED="1567876061482" ID="ID_1788099241" MODIFIED="1567876080657" TEXT="Any waiting line models a queue, for example a lineup at a movie theatre"/>
<node CREATED="1567876081154" ID="ID_1424754155" MODIFIED="1567876099124" TEXT="Can be used to efficiently keep track of the most recently added elements">
<node CREATED="1567912649645" ID="ID_1656308401" MODIFIED="1567912654327" TEXT="x most recent elements"/>
</node>
<node CREATED="1567876100287" ID="ID_422620552" MODIFIED="1567876114112" TEXT="Web server request management where you want first come first serve">
<node CREATED="1567912658327" ID="ID_928945960" MODIFIED="1567912660990" TEXT="web server">
<node CREATED="1567912661203" ID="ID_1729824058" MODIFIED="1567924990763" TEXT="limit number of requests"/>
</node>
</node>
<node CREATED="1567876115307" ID="ID_66233979" MODIFIED="1567876125475" TEXT="Breadth first search (BFS) graph traversal"/>
</node>
<node CREATED="1567875246983" ID="ID_589812612" MODIFIED="1567875252714" TEXT="Complexity Analysis">
<node CREATED="1567925034847" ID="ID_1458160180" MODIFIED="1567925039431" TEXT="Enqueue">
<node CREATED="1567925039901" ID="ID_1747013365" MODIFIED="1567925041271" TEXT="O(1)"/>
</node>
<node CREATED="1567925042983" ID="ID_149013510" MODIFIED="1567925044751" TEXT="Dequeue">
<node CREATED="1567925045064" ID="ID_339379555" MODIFIED="1567925046968" TEXT="O(1)"/>
</node>
<node CREATED="1567925047814" ID="ID_785683913" MODIFIED="1567925050073" TEXT="Peek">
<node CREATED="1567925050339" ID="ID_1734584947" MODIFIED="1567925052016" TEXT="O(1)"/>
</node>
<node CREATED="1567925053542" ID="ID_1144454918" MODIFIED="1567925055511" TEXT="Contains">
<node CREATED="1567925055974" ID="ID_1711752867" MODIFIED="1567925057295" TEXT="O(n)"/>
</node>
<node CREATED="1567925058380" ID="ID_146970559" MODIFIED="1567925059879" TEXT="Removal">
<node CREATED="1567925063256" ID="ID_391550369" MODIFIED="1567925064487" TEXT="O(n)"/>
</node>
<node CREATED="1567925065653" ID="ID_955457785" MODIFIED="1567925068296" TEXT="Is Empty">
<node CREATED="1567925070237" ID="ID_1283036862" MODIFIED="1567925071471" TEXT="O(1)"/>
</node>
</node>
<node CREATED="1567875252931" ID="ID_267068591" MODIFIED="1567875264352" TEXT="Queue Breadth First Search (BFS) example">
<node CREATED="1567925210352" ID="ID_1178615574" MODIFIED="1567925219568" TEXT="Graph">
<node CREATED="1567925219798" ID="ID_1263901226" MODIFIED="1567925221282" TEXT="network"/>
</node>
<node CREATED="1567925231946" ID="ID_1063213379" MODIFIED="1567925239780" TEXT="Visit all neighbors first">
<node CREATED="1567925339593" ID="ID_1663016612" MODIFIED="1567925344753" TEXT="pseudocode">
<node CREATED="1567925345014" ID="ID_407391168" MODIFIED="1567925425956">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Let Q be a Queue
    </p>
    <p>
      Q.enqueue(starting_node)
    </p>
    <p>
      starting_node.visited = true
    </p>
    <p>
      
    </p>
    <p>
      While Q is not empty Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;node = Q.dequeue()
    </p>
    <p>
      &#160;
    </p>
    <p>
      &#160;&#160;&#160;&#160;For neighbour in neighbours(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If neighbour has not be visited:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;neighbour.visited = true
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q.enqueue(neighbour)
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567875269668" ID="ID_1551527789" MODIFIED="1567875275682" TEXT="Implementation Details">
<node CREATED="1567875276027" ID="ID_494219592" MODIFIED="1567875285634" TEXT="How to enqueue (add) elements to a queue"/>
<node CREATED="1567875286119" ID="ID_1284956826" MODIFIED="1567875296171" TEXT="How to dequeue (remove) elements from a queue"/>
</node>
<node CREATED="1567875297444" ID="ID_1558954493" MODIFIED="1567875301851" TEXT="Code Implementation">
<node CREATED="1567925582370" ID="ID_534483534" MODIFIED="1567925585746" TEXT="Singly linked list">
<node CREATED="1567925590691" ID="ID_1167338103" MODIFIED="1567925610068" TEXT="As we enqueue, push tail pointer forward"/>
<node CREATED="1567925623381" ID="ID_915551759" MODIFIED="1567925635482" TEXT="As we dequeue, push the head pointer forward"/>
</node>
<node CREATED="1567927203841" ID="ID_1130257495" MODIFIED="1567927210275" TEXT="Implement Iterable"/>
<node CREATED="1567927369673" ID="ID_1764699491" MODIFIED="1567927373071" TEXT="isEmpty"/>
<node CREATED="1567927374127" ID="ID_1608192963" MODIFIED="1567927375454" TEXT="size"/>
<node CREATED="1567927376255" ID="ID_1617711611" MODIFIED="1567927437923" TEXT="static array based queue">
<node CREATED="1567927438125" ID="ID_52190493" MODIFIED="1567927440936" TEXT="home work"/>
</node>
</node>
</node>
<node CREATED="1567875322692" ID="ID_603148716" MODIFIED="1567875326351" TEXT="Discussion"/>
</node>
<node CREATED="1567047660377" ID="ID_681540935" MODIFIED="1567047668411" TEXT="Breadth first search and queue implementation"/>
<node CREATED="1567047670440" ID="ID_1992317809" MODIFIED="1567047673945" TEXT="Queue source code"/>
</node>
<node CREATED="1567047679733" ID="ID_621356158" MODIFIED="1567047688824" POSITION="left" TEXT="Priority queues">
<node CREATED="1567047692065" ID="ID_356779383" MODIFIED="1567047697048" TEXT="What is a priority queue?">
<node CREATED="1567927484233" ID="ID_1738146176" MODIFIED="1567927486616" TEXT="Outline">
<node CREATED="1567927489529" ID="ID_243588299" MODIFIED="1567927498557" TEXT="Discussion &amp; Examples of PQs">
<node CREATED="1567927501449" ID="ID_1149790374" MODIFIED="1567927505551" TEXT="What is a PQ?">
<node CREATED="1567927708254" ID="ID_866861179" MODIFIED="1567927771728" TEXT="A priority queue is an Abstract Data Type (ADT) that operates similar to a normal queue except that each element has a certain priority. The priority of the elements in the priority queue determine the order in which elements are removed from the PQ"/>
<node CREATED="1567927798155" ID="ID_254216768" MODIFIED="1567927850030" TEXT="Note: Priority queues only supports comparable data, meaning the data inserted into the priority queue must be able to be ordered in some way either from least to greatest or greatest to least. This is so that we are able to assign relative priorities to each element. ">
<node CREATED="1567928080144" ID="ID_1774200146" MODIFIED="1567928082027" TEXT="Example">
<node CREATED="1567928085715" ID="ID_168261323" MODIFIED="1567928087345" TEXT="order">
<node CREATED="1567928087601" ID="ID_827309055" MODIFIED="1567928091954" TEXT="least to greatest number">
<node CREATED="1567928115426" ID="ID_1106455735" MODIFIED="1567928119322" TEXT="poll()">
<node CREATED="1567928119961" ID="ID_238234236" MODIFIED="1567928130838" TEXT="remove the element that has the highest priority"/>
</node>
<node CREATED="1567928233920" ID="ID_336213176" MODIFIED="1567928239934" TEXT="uses heap for implementation"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567927505784" ID="ID_1739084500" MODIFIED="1567927509576" TEXT="What is a heap?">
<node CREATED="1567928243382" ID="ID_1587978489" MODIFIED="1567928289943" TEXT="A heap is a tree based DS that satisfies the heap invariant (also called heap property): If A is a parent node of B then A is ordered with respect to B for all nodes A, B in the heap">
<node CREATED="1567928349904" ID="ID_746824915" MODIFIED="1567928351770" TEXT="Max heap">
<node CREATED="1567928353662" ID="ID_1226347480" MODIFIED="1567928356065" TEXT="A &gt;= B"/>
</node>
<node CREATED="1567928356930" ID="ID_1629362705" MODIFIED="1567928358443" TEXT="Min heap">
<node CREATED="1567928358747" ID="ID_135923404" MODIFIED="1567928360561" TEXT="A &lt;= B"/>
</node>
</node>
<node CREATED="1567928402619" ID="ID_1463459892" MODIFIED="1567928404805" TEXT="Why heaps?">
<node CREATED="1567928404997" ID="ID_166657406" MODIFIED="1567928411221" TEXT="Canonical data structure"/>
</node>
</node>
<node CREATED="1567927509814" ID="ID_1204252414" MODIFIED="1567927519024" TEXT="When and where is a PQ used?">
<node CREATED="1567928579618" ID="ID_806726178" MODIFIED="1567928596183" TEXT="Used in certain implementations of Dijkstra&apos;s Shortest Path algorithms"/>
<node CREATED="1567928597550" ID="ID_1360968967" MODIFIED="1567928619842" TEXT="Anytime you need the dynamically fetch the &apos;next best&apos; or &apos;next worst&apos; element"/>
<node CREATED="1567928624119" ID="ID_422539195" MODIFIED="1567928641283" TEXT="Used in Huffman coding (which is often used for lossless data compression)."/>
<node CREATED="1567928642637" ID="ID_1036216665" MODIFIED="1567928677700" TEXT="Best First Search (BFS) algorithms such as A* use PQs to continuously grab the next most promising node.">
<node CREATED="1567928735137" ID="ID_213306786" MODIFIED="1567928736963" TEXT="Graphs"/>
</node>
<node CREATED="1567928679645" ID="ID_1840973684" MODIFIED="1567928688353" TEXT="Used by Minimum Spanning Tree (MST) algorithms">
<node CREATED="1567928740117" ID="ID_1013726165" MODIFIED="1567928742011" TEXT="Digraphs"/>
</node>
<node CREATED="1567928746880" ID="ID_850920072" MODIFIED="1567928751815" TEXT="Usually Graph Theory algorithms"/>
</node>
<node CREATED="1567927519282" ID="ID_1788891877" MODIFIED="1567927530648" TEXT="How to turn a Min PQ into a Max PQ">
<node CREATED="1567928984587" ID="ID_1181084894" MODIFIED="1567928986308" TEXT="Problem">
<node CREATED="1567928986604" ID="ID_1465917842" MODIFIED="1567929030549" TEXT="Often the standard library of most programming languages only provide a min PQ which sorts by smallest elements first, but sometimes we need a Max PQ"/>
<node CREATED="1567929083577" ID="ID_651444612" MODIFIED="1567929110903" TEXT="Since elements in a priority queue are comparable they implement some sort of comparable interface which we can simply negate to achieve a Max heap">
<node CREATED="1567949186921" ID="ID_949613378" MODIFIED="1567949201784" TEXT="To convert, negate or convert the output of comparable interface">
<node CREATED="1567949210449" ID="ID_2998541" MODIFIED="1567949213664" TEXT="example">
<node CREATED="1567949213922" ID="ID_1979869853" MODIFIED="1567949247431" TEXT="Let x, y be numbers in the PQ. For a min PQ, if x &lt;= y then x comes out of the PQ before y, so the negation of this is if x &gt;= y then y comes out before x"/>
<node CREATED="1567949289426" ID="ID_243624665" MODIFIED="1567949317886" TEXT="An alternative method for numbers is to negate the numbers as you insert them into the PQ and negate them again when they are taken out. This has the same effect as negating the comparator">
<node CREATED="1567949319275" ID="ID_1661148376" MODIFIED="1567949322067" TEXT="works for numbers"/>
</node>
</node>
</node>
<node CREATED="1567949350482" ID="ID_748272057" MODIFIED="1567949357547" TEXT="Strings">
<node CREATED="1567949357764" ID="ID_217903430" MODIFIED="1567949423115" TEXT="Suppose lex is a comparator for strings which sorts strings in exicographic order (the default in most programming languages). Then let nlex be the negation of lex, and also let s1, s2 be strings">
<node CREATED="1567949429811" ID="ID_1703801504" MODIFIED="1567949443804" TEXT="lex(s1, s2) = -1 if s1 &lt; s2 lexicographically"/>
<node CREATED="1567949445172" ID="ID_1414813457" MODIFIED="1567949459355" TEXT="lex(s1, s2) = 0 if s1 = s2 lexicographically"/>
<node CREATED="1567949459755" ID="ID_388778203" MODIFIED="1567949472808" TEXT="lex(s1, s2) = +1 if s1 &gt; s2 lexicographically"/>
<node CREATED="1567949474007" ID="ID_874685129" MODIFIED="1567949491783" TEXT="nlex(s1, s2) = -(-1) = +1 s1 &lt; s2 lexicographically"/>
<node CREATED="1567949492154" ID="ID_323950069" MODIFIED="1567949509337" TEXT="nlex(s1, s2) = -(0) = 0 s1 = s2 lexicographically"/>
<node CREATED="1567949509590" ID="ID_270727751" MODIFIED="1567949524954" TEXT="nlex(s1, s2) = -(+1) = -1 s1 &gt; s2 lexicographically"/>
</node>
<node CREATED="1567949549295" ID="ID_625304416" MODIFIED="1567949551746" TEXT="example">
<node CREATED="1567949552552" ID="ID_386663184" MODIFIED="1567949570115" TEXT="By adding all these strings on the sright to the PQ with the lex comparator, we obtain the following:"/>
<node CREATED="1567949574737" ID="ID_70144343" MODIFIED="1567949575885" TEXT="nlex">
<node CREATED="1567949576793" ID="ID_1426988527" MODIFIED="1567949579685" TEXT="reverses the order"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567927531631" ID="ID_1046941321" MODIFIED="1567927536514" TEXT="Complexity Analysis">
<node CREATED="1567928757354" ID="ID_1231367622" MODIFIED="1567928764200" TEXT="Binary Heap construction">
<node CREATED="1567928764888" ID="ID_481229147" MODIFIED="1567928766180" TEXT="O(n)">
<node CREATED="1567928771828" ID="ID_785313119" MODIFIED="1567928777724" TEXT="Heap sorting algorithm"/>
</node>
</node>
<node CREATED="1567928779161" ID="ID_33050165" MODIFIED="1567928780597" TEXT="Polling">
<node CREATED="1567928780834" ID="ID_361001967" MODIFIED="1567928783756" TEXT="O(log(n))"/>
</node>
<node CREATED="1567928788973" ID="ID_1258056983" MODIFIED="1567928790605" TEXT="Peeking">
<node CREATED="1567928790828" ID="ID_1693170222" MODIFIED="1567928792471" TEXT="O(1)"/>
</node>
<node CREATED="1567928794570" ID="ID_1551900460" MODIFIED="1567928795676" TEXT="Adding">
<node CREATED="1567928796612" ID="ID_342051199" MODIFIED="1567928802974" TEXT="O(log(n))">
<node CREATED="1567928806041" ID="ID_985922242" MODIFIED="1567928811707" TEXT="Bubbling up value to re-order"/>
</node>
</node>
<node CREATED="1567928814629" ID="ID_1951105889" MODIFIED="1567928825157" TEXT="Naive Removing">
<node CREATED="1567928825341" ID="ID_1975499527" MODIFIED="1567928827541" TEXT="O(n)"/>
</node>
<node CREATED="1567928835182" ID="ID_1040666342" MODIFIED="1567928847415" TEXT="Advanced removing with help from a hash table">
<node CREATED="1567928847760" ID="ID_1397203816" MODIFIED="1567928851422" TEXT="O(log(n))">
<node CREATED="1567928925815" ID="ID_362130085" MODIFIED="1567928928826" TEXT="extra space"/>
</node>
</node>
<node CREATED="1567928853458" ID="ID_46590163" MODIFIED="1567928856671" TEXT="Naive contains">
<node CREATED="1567928857143" ID="ID_979621951" MODIFIED="1567928861822" TEXT="O(n)"/>
</node>
<node CREATED="1567928862744" ID="ID_562451747" MODIFIED="1567928870448" TEXT="Contains check with help of a hash table">
<node CREATED="1567928870622" ID="ID_137839379" MODIFIED="1567928873487" TEXT="O(1)"/>
</node>
</node>
</node>
<node CREATED="1567927538186" ID="ID_805860522" MODIFIED="1567927546384" TEXT="Binary heap PQ Implementation Details">
<node CREATED="1567927546803" ID="ID_1069320867" MODIFIED="1567927580974" TEXT="Heap sinking and swimming (also called sift down &amp; sift up or bubble up &amp; bubble down"/>
<node CREATED="1567927589436" ID="ID_774595642" MODIFIED="1567927593895" TEXT="Adding elements to PQ"/>
<node CREATED="1567927594246" ID="ID_1621734662" MODIFIED="1567927603643" TEXT="Removing (polling) elements from PQ"/>
<node CREATED="1567949707717" ID="ID_73975884" MODIFIED="1567949717684" TEXT="Ways of Implementing a Priority Queue">
<node CREATED="1567949719213" ID="ID_1547960885" MODIFIED="1567949741532" TEXT="Priority queues are usually implemented with heaps since this gives them the best possible time complexity"/>
<node CREATED="1567949742537" ID="ID_70839202" MODIFIED="1567949804897" TEXT="The Priority Queue (PQ) is an Abstract Data Types (ADT), hence heaps are not the only way to implement PQs. As an example, we could use an unsorted list, but this would not give us the best possible time complexity">
<node CREATED="1567949832983" ID="ID_1495685115" MODIFIED="1567949840485" TEXT="Heaps give best possible time complexity"/>
</node>
</node>
<node CREATED="1567949877188" ID="ID_158494613" MODIFIED="1567949884718" TEXT="Priority Queue With Binary Heap">
<node CREATED="1567949885029" ID="ID_1932206572" MODIFIED="1567949900209" TEXT="There are many types of heaps we could use to implement a priority queue including">
<node CREATED="1567949900424" ID="ID_1358092490" MODIFIED="1567949904168" TEXT="Binary Heap">
<node CREATED="1567949922703" ID="ID_1199673573" MODIFIED="1567949924904" TEXT="simple"/>
<node CREATED="1567949930440" ID="ID_1530505205" MODIFIED="1567949951318" TEXT="A binary heap is a binary tree that supports the heap invariant. In a binary tree every node has exactly two children">
<node CREATED="1567949960743" ID="ID_1496513145" MODIFIED="1567949966323" TEXT="leaves have null children"/>
</node>
<node CREATED="1567949975752" ID="ID_1054380863" MODIFIED="1567950003847" TEXT="A complete binary tree is a tree in which at every level, except possibly the last is completely filled and all the nodes are as far left as possible">
<node CREATED="1567950007801" ID="ID_1005908597" MODIFIED="1567950016988" TEXT="insertion is at bottom left"/>
</node>
<node CREATED="1567950047847" ID="ID_1002203762" MODIFIED="1567950050790" TEXT="Representation">
<node CREATED="1567950051227" ID="ID_357058934" MODIFIED="1567950067878" TEXT="array">
<node CREATED="1567950081493" ID="ID_231498599" MODIFIED="1567950083375" TEXT="insert">
<node CREATED="1567950083598" ID="ID_1781300889" MODIFIED="1567950088488" TEXT="last"/>
</node>
<node CREATED="1567950143938" ID="ID_1058424522" MODIFIED="1567950144949" TEXT="read">
<node CREATED="1567950145308" ID="ID_1623933449" MODIFIED="1567950150514" TEXT="in order"/>
<node CREATED="1567950160664" ID="ID_1355689727" MODIFIED="1567950166928" TEXT="easy to access parents and children">
<node CREATED="1567956289934" ID="ID_1859051456" MODIFIED="1567956295274" TEXT="Let i be the parent node index">
<node CREATED="1567956296089" ID="ID_102512848" MODIFIED="1567956305898" TEXT="left child index: 2i + 1">
<node CREATED="1567956321612" ID="ID_1899068390" MODIFIED="1567956325100" TEXT="zero based"/>
</node>
<node CREATED="1567956306404" ID="ID_983450311" MODIFIED="1567956314219" TEXT="right child index: 2i + 2">
<node CREATED="1567956316858" ID="ID_146825227" MODIFIED="1567956320203" TEXT="zero based"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567950091038" ID="ID_1606576895" MODIFIED="1567950096199" TEXT="index tree">
<node CREATED="1567950096755" ID="ID_629510955" MODIFIED="1567950104440" TEXT="not very elegant"/>
</node>
<node CREATED="1567956437211" ID="ID_1089430741" MODIFIED="1567956445105" TEXT="Adding elements to Binary Heap">
<node CREATED="1567956446251" ID="ID_1196345464" MODIFIED="1567956527803">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: put the new node at bottom left
    </p>
    <p>
      Step 2: bubble up the node
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with parent
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1567956611351" ID="ID_1618022818" MODIFIED="1567956622919" TEXT="Removing elements from Binary heap">
<node CREATED="1567956752227" ID="ID_970781002" MODIFIED="1567956754935" TEXT="Poll()">
<node CREATED="1567956769262" ID="ID_991189842" MODIFIED="1567956772570" TEXT="removing root">
<node CREATED="1567956831611" ID="ID_1330163141" MODIFIED="1567956919255">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: swap root with rightmost leaf
    </p>
    <p>
      Step 2: remove the rightmost leaf
    </p>
    <p>
      Step 3: bubble down the root (if heap invariant is not satisfied)
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with smallest child
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat the above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
<node CREATED="1567957157222" ID="ID_1174713805" MODIFIED="1567957162796" TEXT="O(log(n))"/>
</node>
</node>
</node>
<node CREATED="1567956756128" ID="ID_1212349169" MODIFIED="1567956761487" TEXT="Remove(&lt;element&gt;)">
<node CREATED="1567956974468" ID="ID_3055490" MODIFIED="1567957126776">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Search from root to last leaf (O(n))
    </p>
    <p>
      Step 2: Swap the &lt;element&gt; with last leaf
    </p>
    <p>
      Step 3: Remove the last leaf
    </p>
    <p>
      Step 4: Bubble down if possible or bubble up if not
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with smallest child
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat the above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
<node CREATED="1567957164165" ID="ID_1636111617" MODIFIED="1567957165678" TEXT="O(n)">
<node CREATED="1567957179682" ID="ID_1820784911" MODIFIED="1567957191310" TEXT="There is a better way to improve to O(log(n))">
<node CREATED="1567957313766" ID="ID_1608366648" MODIFIED="1567957349359" TEXT="The inefficiency of the removal algorithm comes from the fact that we have to perform a linear search to find out where an element is indexed at. What if instead we did a lookup using a Hashtable to find out where a node is indexed at?"/>
<node CREATED="1567957351855" ID="ID_1446472411" MODIFIED="1567957378176" TEXT="A hashtable provides a constant time lookup and update for a mapping from a key (the node value) to a value (the index).">
<node CREATED="1568042442956" ID="ID_1738109903" MODIFIED="1568042450397" TEXT="Every node is mapped to an index"/>
</node>
<node CREATED="1568042460645" ID="ID_273434116" MODIFIED="1568042487498" TEXT="Caveat: What if there are two or more nodes with the same value? What problems would that cause?">
<node CREATED="1568042497356" ID="ID_561055243" MODIFIED="1568042508199" TEXT="Dealing with the multiple value problem">
<node CREATED="1568042509033" ID="ID_1185209261" MODIFIED="1568042555456" TEXT="Instead of mapping one value to one position we will map one value to multiple position. We can maintain a Set or Tree Set of indexes for which a particular node value (key) maps to">
<node CREATED="1568076572310" ID="ID_1143491448" MODIFIED="1568076585145" TEXT="key: node value"/>
<node CREATED="1568076585391" ID="ID_923571877" MODIFIED="1568076594809" TEXT="value: position(s)"/>
<node CREATED="1568076598950" ID="ID_285304010" MODIFIED="1568076601521" TEXT="example">
<node CREATED="1568076602433" ID="ID_1587428585" MODIFIED="1568076667686">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Node Value| Position(s)
    </p>
    <p>
      2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 0, 2, 6
    </p>
    <p>
      7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 1, 4
    </p>
    <p>
      11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 3
    </p>
    <p>
      13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 5
    </p>
  </body>
</html></richcontent>
<node CREATED="1568076708062" ID="ID_31764313" MODIFIED="1568076718362" TEXT="If we swap in tree, we swap in table"/>
</node>
</node>
<node CREATED="1568076736839" ID="ID_51747619" MODIFIED="1568076748170" TEXT="Removing Elements from Binary Heap in O(log(n))">
<node CREATED="1568076749560" ID="ID_1487134193" MODIFIED="1568076771033" TEXT="Question: If we want to remove a repeated node in our heap, which node do we remove and does it matter which one we pick?">
<node CREATED="1568076797580" ID="ID_979531571" MODIFIED="1568076818872" TEXT="Answer: No it doesn&apos;t matter which node we remove as long as we satisfy the heap invariant in the end"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567949904423" ID="ID_1111580034" MODIFIED="1567949908152" TEXT="Fibonacci Heap"/>
<node CREATED="1567949908481" ID="ID_1230783629" MODIFIED="1567949911656" TEXT="Binomial Heap"/>
<node CREATED="1567949911880" ID="ID_358692" MODIFIED="1567949914720" TEXT="Pairing Heap"/>
</node>
</node>
</node>
<node CREATED="1567927605260" ID="ID_1878263323" MODIFIED="1567927609055" TEXT="Code Implementation">
<node CREATED="1568077137995" ID="ID_152980391" MODIFIED="1568077150210" TEXT="Implement Comparable&lt;T&gt;"/>
<node CREATED="1568077259397" ID="ID_879975942" MODIFIED="1568077263101" TEXT="heapify?">
<node CREATED="1568077301604" ID="ID_81292152" MODIFIED="1568077320451" TEXT="construct priority queue using heapify in O(n) time, a great explanation can be found">
<node CREATED="1568077332930" ID="ID_1404815417" MODIFIED="1568077357882" TEXT="http://www.cs.umd.edu/~meesh/351/mount/lectures/lect14-heapsort-analysis-part.pdf"/>
</node>
</node>
<node CREATED="1568077405032" ID="ID_1119387087" MODIFIED="1568077408045" TEXT="isEmpty"/>
<node CREATED="1568077408898" ID="ID_937006672" MODIFIED="1568077410606" TEXT="clear"/>
<node CREATED="1568077413595" ID="ID_340383998" MODIFIED="1568077414885" TEXT="size"/>
<node CREATED="1568077416513" ID="ID_1604124078" MODIFIED="1568077420621" TEXT="peek"/>
<node CREATED="1568077438249" ID="ID_1029750898" MODIFIED="1568077439508" TEXT="poll">
<node CREATED="1568077451719" ID="ID_780690205" MODIFIED="1568077454606" TEXT="return the element"/>
</node>
<node CREATED="1568077457332" ID="ID_1826318537" MODIFIED="1568077458615" TEXT="contains"/>
<node CREATED="1568077524044" ID="ID_1090035191" MODIFIED="1568077524829" TEXT="add"/>
<node CREATED="1568077574028" ID="ID_965458629" MODIFIED="1568077575626" TEXT="less">
<node CREATED="1568077576347" ID="ID_371562966" MODIFIED="1568077581026" TEXT="if nodei &lt;= nodej">
<node CREATED="1568077589949" ID="ID_969149742" MODIFIED="1568077598290" TEXT="implements compareTo method"/>
</node>
</node>
<node CREATED="1568077688819" ID="ID_887344753" MODIFIED="1568077691083" TEXT="sink"/>
<node CREATED="1568077760574" ID="ID_1262028804" MODIFIED="1568077763761" TEXT="swap"/>
<node CREATED="1568077784406" ID="ID_864467679" MODIFIED="1568077788804" TEXT="mapSwap"/>
<node CREATED="1568077799207" ID="ID_557891651" MODIFIED="1568077802526" TEXT="remove"/>
<node CREATED="1568077829858" ID="ID_1790732555" MODIFIED="1568077832060" TEXT="removeAt"/>
<node CREATED="1568077932782" ID="ID_1039253573" MODIFIED="1568077935766" TEXT="isMinHeap">
<node CREATED="1568077939159" ID="ID_226646065" MODIFIED="1568077946158" TEXT="Checks the integrity"/>
</node>
<node CREATED="1568078017846" ID="ID_1084899389" MODIFIED="1568078020080" TEXT="mapAdd"/>
<node CREATED="1568078020407" ID="ID_1575924523" MODIFIED="1568078023528" TEXT="mapRemove">
<node CREATED="1568078026877" ID="ID_1650852955" MODIFIED="1568078032087" TEXT="Uses TreeSet">
<node CREATED="1568078032419" ID="ID_716690057" MODIFIED="1568078041326" TEXT="Balanced Binary Search Tree"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047698146" ID="ID_948257874" MODIFIED="1567047705098" TEXT="Min heaps and Max heaps">
<node CREATED="1567928519976" ID="ID_144466936" MODIFIED="1567928541631" TEXT="All heaps must be trees (can have multiple roots)">
<node CREATED="1567928544577" ID="ID_1495467005" MODIFIED="1567928548022" TEXT="no cycles allowed"/>
</node>
</node>
<node CREATED="1567047706464" ID="ID_334392311" MODIFIED="1567047712854" TEXT="Priority queue inserting elements"/>
<node CREATED="1567047714112" ID="ID_1738142256" MODIFIED="1567047721459" TEXT="Priority queue removing elements"/>
<node CREATED="1567047722745" ID="ID_1647223488" MODIFIED="1567047727545" TEXT="Priority queue source code"/>
</node>
<node CREATED="1567047734303" ID="ID_131011986" MODIFIED="1567047742776" POSITION="right" TEXT="Union find/Disjoint set">
<node CREATED="1567047743922" ID="ID_1964427090" MODIFIED="1567047748417" TEXT="Union find introduction">
<node CREATED="1568078144253" ID="ID_1263656862" MODIFIED="1568078147915" TEXT="Outline">
<node CREATED="1568078148124" ID="ID_334747435" MODIFIED="1568078153978" TEXT="Discussion &amp; Examples">
<node CREATED="1568078165779" ID="ID_1537024997" MODIFIED="1568078173275" TEXT="What is Union Find?">
<node CREATED="1568078280690" ID="ID_142617000" MODIFIED="1568078308787" TEXT="Union Find is a data structure that keeps track of elements which are split into one or more disjoint sets. Its has two primary operations: find and union">
<node CREATED="1568078340666" ID="ID_1201785571" MODIFIED="1568078341768" TEXT="find">
<node CREATED="1568078347406" ID="ID_875295430" MODIFIED="1568078360415" TEXT="given an element, it tells what group the element belongs to"/>
</node>
<node CREATED="1568078366312" ID="ID_499729653" MODIFIED="1568078368129" TEXT="union">
<node CREATED="1568078368480" ID="ID_1922498374" MODIFIED="1568078372515" TEXT="merges two groups together"/>
</node>
</node>
</node>
<node CREATED="1568078173514" ID="ID_1608169854" MODIFIED="1568078179323" TEXT="Magnets example">
<node CREATED="1568078393590" ID="ID_421108015" MODIFIED="1568078409494" TEXT="merge closest magnets"/>
</node>
<node CREATED="1568078179571" ID="ID_731290394" MODIFIED="1568078187953" TEXT="When and where is a Union Find used?">
<node CREATED="1568078509369" ID="ID_1978700048" MODIFIED="1568078519549" TEXT="Kruskal&apos;s minimum spanning tree algorithm"/>
<node CREATED="1568078521595" ID="ID_1793837877" MODIFIED="1568078525287" TEXT="Grid percolation">
<node CREATED="1568078569302" ID="ID_484098103" MODIFIED="1568078581823" TEXT="to see if there is a path from bottom of the grid to the top of the grid">
<node CREATED="1568078595697" ID="ID_1156579490" MODIFIED="1568078601964" TEXT="implemented using merging paths"/>
</node>
</node>
<node CREATED="1568078526453" ID="ID_280357038" MODIFIED="1568078531103" TEXT="Network connectivity">
<node CREATED="1568078657736" ID="ID_1666616653" MODIFIED="1568078672700" TEXT="are two vertices in a graph connected to each other through a series of edges"/>
</node>
<node CREATED="1568078531363" ID="ID_17774009" MODIFIED="1568078538217" TEXT="Least common ancestor in trees"/>
<node CREATED="1568078538471" ID="ID_408909853" MODIFIED="1568078542342" TEXT="Image processing"/>
</node>
<node CREATED="1568078189067" ID="ID_184098431" MODIFIED="1568078199618" TEXT="Kruskal&apos;s minimum spanning tree algorithm">
<node CREATED="1568087439143" ID="ID_1282921816" MODIFIED="1568087483552" TEXT="Given a graph G = (V, E) we want to find a Minimum Spanning Tree in the graph (it may not be unique). A minimum spanning tree is a subset of the edges which connect all vertices in the graph with the minimal total edge cost">
<node CREATED="1568087758715" ID="ID_1984689568" MODIFIED="1568087760927" TEXT="Steps">
<node CREATED="1568087761223" ID="ID_1804941219" MODIFIED="1568087849572">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Sort edges by ascending edge weight
    </p>
    <p>
      Step 2: Walk through the sorted edges and look at the two nodes the edge belongs to, if the nodes are alrady unified we don't include this edge, otherwise we include it and unify the nodes.
    </p>
    <p>
      Step 3: The algorithm terminates when every edge has been processed or all the vertices have been unified.<br /><br />
    </p>
  </body>
</html></richcontent>
<node CREATED="1568087921481" ID="ID_385307345" MODIFIED="1568087923957" TEXT="example">
<node CREATED="1568087924235" ID="ID_328806408" MODIFIED="1568088010393">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      I to J = 0
    </p>
    <p>
      A to E = 1
    </p>
    <p>
      C to I = 1
    </p>
    <p>
      E to F = 1
    </p>
    <p>
      G to H = 1
    </p>
    <p>
      B to D = 1
    </p>
    <p>
      C to J = 1
    </p>
    <p>
      D to E = 2
    </p>
    <p>
      D to H = 2
    </p>
    <p>
      A to D = 4
    </p>
    <p>
      B to C = 4
    </p>
    <p>
      C to H = 4
    </p>
    <p>
      G to I = 4
    </p>
    <p>
      A to B = 5
    </p>
    <p>
      D to F = 5
    </p>
    <p>
      H to I = 6
    </p>
    <p>
      F to G = 7
    </p>
    <p>
      D to G = 11
    </p>
  </body>
</html></richcontent>
<node CREATED="1568089646180" ID="ID_1425195954" MODIFIED="1568089651342" TEXT="Unify IJ"/>
<node CREATED="1568089657359" ID="ID_711122726" MODIFIED="1568089659817" TEXT="Unify AE"/>
<node CREATED="1568089666354" ID="ID_1383068915" MODIFIED="1568089673633" TEXT="Add CI to IJ group"/>
<node CREATED="1568089678324" ID="ID_892609752" MODIFIED="1568089688374" TEXT="Unify EF"/>
<node CREATED="1568089688936" ID="ID_862850876" MODIFIED="1568089694238" TEXT="Unify GH"/>
<node CREATED="1568089694939" ID="ID_1446212452" MODIFIED="1568089701230" TEXT="Unify BD"/>
<node CREATED="1568089719462" ID="ID_1609339144" MODIFIED="1568089727956" TEXT="Ignore CJ">
<node CREATED="1568089728625" ID="ID_1446072022" MODIFIED="1568089732971" TEXT="Use find"/>
<node CREATED="1568089737576" ID="ID_1645677530" MODIFIED="1568089741531" TEXT="forms cycle"/>
</node>
<node CREATED="1568089742937" ID="ID_1712853685" MODIFIED="1568089760808" TEXT="Add DE to BD">
<node CREATED="1568089761145" ID="ID_1230992962" MODIFIED="1568089763585" TEXT="Use union"/>
</node>
<node CREATED="1568089770447" ID="ID_1050381757" MODIFIED="1568089784823" TEXT="Add HG to DE group"/>
<node CREATED="1568089786784" ID="ID_827166586" MODIFIED="1568089793009" TEXT="Ignore AD"/>
<node CREATED="1568089798826" ID="ID_1776634390" MODIFIED="1568089822541" TEXT="Merge BC to DH group"/>
</node>
</node>
<node CREATED="1568089830605" ID="ID_687747281" MODIFIED="1568089837909" TEXT="Data Structure used">
<node CREATED="1568089838142" ID="ID_272549175" MODIFIED="1568089840805" TEXT="Union-Find">
<node CREATED="1568167048745" ID="ID_580039251" MODIFIED="1568167053957" TEXT="Constructing Union Find">
<node CREATED="1568167055388" ID="ID_1697572879" MODIFIED="1568167119046" TEXT="To begin using Union Find, first construct a bijection (a mapping) between your objects and the integers in the rangle [0, n)."/>
<node CREATED="1568167120207" ID="ID_1831206046" MODIFIED="1568167142902" TEXT="Note: This step is not necessary in general, but it will allow us to construct an array-based union find.">
<node CREATED="1568169826017" ID="ID_1444081750" MODIFIED="1568169828985" TEXT="efficient"/>
<node CREATED="1568169831274" ID="ID_571583936" MODIFIED="1568169834505" TEXT="easy to work with"/>
</node>
<node CREATED="1568169842168" ID="ID_1894178734" MODIFIED="1568169865530" TEXT="Randomly assign a mapping between the objects and the integers on the right">
<node CREATED="1568169878803" ID="ID_932267175" MODIFIED="1568169890180" TEXT="Store mappings in hashtable"/>
</node>
<node CREATED="1568169893955" ID="ID_1329743372" MODIFIED="1568169936641" TEXT="Store Union Find information  in an array. Each index hass an associated object (letter in this example) we can lookup through our mapping">
<node CREATED="1568169992588" ID="ID_1763500310" MODIFIED="1568170075938" TEXT="value in the array is currently the index at which it is">
<node CREATED="1568170078027" ID="ID_943535646" MODIFIED="1568170083676" TEXT="It maps to itself"/>
<node CREATED="1568170092276" ID="ID_969372444" MODIFIED="1568170111606" TEXT="As we group the letters, we change values to the group index">
<node CREATED="1568170120944" ID="ID_908710448" MODIFIED="1568170124188" TEXT="Union(C, K)">
<node CREATED="1568170124502" ID="ID_1961113726" MODIFIED="1568170146152" TEXT="C can be K&apos;s Parent">
<node CREATED="1568170150414" ID="ID_1661794539" MODIFIED="1568170155098" TEXT="Change K -&gt; 4"/>
</node>
</node>
<node CREATED="1568170158920" ID="ID_1680230408" MODIFIED="1568170163434" TEXT="Union(F, E)">
<node CREATED="1568170163866" ID="ID_1445343597" MODIFIED="1568170176946" TEXT="F can be E&apos;s Parent">
<node CREATED="1568170177262" ID="ID_96440245" MODIFIED="1568170183640" TEXT="Change F -&gt; 0"/>
</node>
</node>
<node CREATED="1568170188167" ID="ID_533620574" MODIFIED="1568170192641" TEXT="Union(A, J)">
<node CREATED="1568170192898" ID="ID_1307773254" MODIFIED="1568170205520" TEXT="A can be J&apos;s Parent">
<node CREATED="1568170205725" ID="ID_129488827" MODIFIED="1568170227573" TEXT="Change J -&gt; 6"/>
</node>
</node>
<node CREATED="1568170230356" ID="ID_278221946" MODIFIED="1568170267101" TEXT="Union(A, B)">
<node CREATED="1568170235525" ID="ID_1380066484" MODIFIED="1568170278360" TEXT="A can be B&apos;s Parent">
<node CREATED="1568170284681" ID="ID_1072026598" MODIFIED="1568170292379" TEXT="Change B -&gt; 6"/>
</node>
</node>
<node CREATED="1568170387191" ID="ID_276643491" MODIFIED="1568170392487" TEXT="Union(C, D)">
<node CREATED="1568170392703" ID="ID_630546287" MODIFIED="1568170425685" TEXT="C can be D&apos;s Parent">
<node CREATED="1568170426026" ID="ID_630733983" MODIFIED="1568170432429" TEXT="Change D -&gt; 4"/>
</node>
</node>
<node CREATED="1568170522641" ID="ID_1425954323" MODIFIED="1568170526917" TEXT="Union(D, I)">
<node CREATED="1568170529164" ID="ID_1414334197" MODIFIED="1568170537325" TEXT="C can be I&apos;s Parent">
<node CREATED="1568170538260" ID="ID_490380448" MODIFIED="1568170541916" TEXT="Change I -&gt; 4"/>
</node>
</node>
<node CREATED="1568171192226" ID="ID_1088921374" MODIFIED="1568171196956" TEXT="Union(L, F)"/>
<node CREATED="1568171198248" ID="ID_1383654866" MODIFIED="1568171210996" TEXT="Union(C, A)"/>
<node CREATED="1568171217794" ID="ID_322756246" MODIFIED="1568171222780" TEXT="Union(A, B)"/>
<node CREATED="1568171224538" ID="ID_146280339" MODIFIED="1568171227892" TEXT="Union(H, G)"/>
<node CREATED="1568171229085" ID="ID_223595249" MODIFIED="1568171235043" TEXT="Union(H, F)"/>
<node CREATED="1568171235363" ID="ID_39481054" MODIFIED="1568171243293" TEXT="Union(H, B)"/>
</node>
<node CREATED="1568171138811" ID="ID_387087481" MODIFIED="1568171165567" TEXT="If two trees have to be merged, change value of one root to the value of another root">
<node CREATED="1568171166004" ID="ID_26266615" MODIFIED="1568171177195" TEXT="Rest of the node values remain the same"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568171258383" ID="ID_28291819" MODIFIED="1568171259853" TEXT="Summary">
<node CREATED="1568171262649" ID="ID_1690995910" MODIFIED="1568171266581" TEXT="Find Operation">
<node CREATED="1568171271487" ID="ID_309781133" MODIFIED="1568171302334" TEXT="To find which component a particular element belongs to find the root of that component by following the parent nodes until a self loop is reached (a node who&apos;s parent is itself)">
<node CREATED="1568171332535" ID="ID_1712453442" MODIFIED="1568171344300" TEXT="finds the group to which an element belongs to"/>
</node>
</node>
<node CREATED="1568171267052" ID="ID_1402704936" MODIFIED="1568171270405" TEXT="Union Operation">
<node CREATED="1568171407998" ID="ID_303427068" MODIFIED="1568171432469" TEXT="To unify two elements find which are the root nodes ofeach component and if the root nodes are different make one of the root nodes be the parent of the other."/>
<node CREATED="1568173382570" ID="ID_267697709" MODIFIED="1568173384398" TEXT="Remarks">
<node CREATED="1568173384567" ID="ID_267827479" MODIFIED="1568173411990" TEXT="In this data structure, we do not &quot;un-union&quot; elements. In general, this would be very inefficient to do since we would have to update all the children of a node."/>
<node CREATED="1568173413126" ID="ID_386114053" MODIFIED="1568173439806" TEXT="The number of components is equal to the number of roots remaining. Also, remark that the number of root nodes never increases.">
<node CREATED="1568173523892" ID="ID_1646292101" MODIFIED="1568173531067" TEXT="number or root nodes decreases"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568078202332" ID="ID_963249453" MODIFIED="1568078206315" TEXT="Complexity analysis">
<node CREATED="1568078728392" ID="ID_1969977949" MODIFIED="1568078732091" TEXT="Construction">
<node CREATED="1568078732812" ID="ID_874446638" MODIFIED="1568078734243" TEXT="O(n)"/>
</node>
<node CREATED="1568078735356" ID="ID_367350127" MODIFIED="1568078736796" TEXT="Union">
<node CREATED="1568078737164" ID="ID_563029446" MODIFIED="1568078741635" TEXT="alpha(n)">
<node CREATED="1568078748884" ID="ID_1933112710" MODIFIED="1568078780534" TEXT="amortized constant time">
<node CREATED="1568173549306" ID="ID_1339263966" MODIFIED="1568173555988" TEXT="This needs path compression">
<node CREATED="1568173559579" ID="ID_391674643" MODIFIED="1568173613826" TEXT="Checking if H and B belong to the same group takes five hops and in the worst case this is potentially much more"/>
</node>
</node>
</node>
</node>
<node CREATED="1568078743323" ID="ID_99415186" MODIFIED="1568078744627" TEXT="Find">
<node CREATED="1568078745048" ID="ID_1312539418" MODIFIED="1568078748179" TEXT="alpha(n)">
<node CREATED="1568078755216" ID="ID_1495561073" MODIFIED="1568078785027" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078759313" ID="ID_1996246181" MODIFIED="1568078762978" TEXT="Get component size">
<node CREATED="1568078763320" ID="ID_1217236053" MODIFIED="1568078792602" TEXT="alpha(n)">
<node CREATED="1568078792824" ID="ID_381645532" MODIFIED="1568078797480" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078799027" ID="ID_1062785051" MODIFIED="1568078802714" TEXT="Check if connected">
<node CREATED="1568078802911" ID="ID_694425404" MODIFIED="1568078806178" TEXT="alpha(n)">
<node CREATED="1568078806344" ID="ID_548940453" MODIFIED="1568078810095" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078811049" ID="ID_251154875" MODIFIED="1568078814193" TEXT="Count components">
<node CREATED="1568078814410" ID="ID_517662786" MODIFIED="1568078817162" TEXT="O(1)"/>
</node>
</node>
</node>
<node CREATED="1568078154267" ID="ID_1975942754" MODIFIED="1568078160021" TEXT="Implementation Details">
<node CREATED="1568078208178" ID="ID_293248170" MODIFIED="1568078213659" TEXT="Find &amp; Union operations"/>
<node CREATED="1568078213897" ID="ID_1007089506" MODIFIED="1568078219098" TEXT="Path compression">
<node CREATED="1568174063005" ID="ID_977710336" MODIFIED="1568174073639" TEXT="Boost in efficiency">
<node CREATED="1568174110369" ID="ID_1136559578" MODIFIED="1568174123076" TEXT="Hypothetical Union find path compression example">
<node CREATED="1568174124047" ID="ID_1777714048" MODIFIED="1568174161645">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; F
    </p>
    <p>
      L -&gt; K -&gt; J -&gt; I -&gt; H -&gt; G
    </p>
  </body>
</html></richcontent>
<node CREATED="1568174171517" ID="ID_309016610" MODIFIED="1568174182385" TEXT="Union(E, L)">
<node CREATED="1568174187825" ID="ID_67655286" MODIFIED="1568174591927">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Find root node of E
    </p>
    <p>
      Step 2: Find root node of L
    </p>
    <p>
      Step 3: Point each of the nodes along the path to root node
    </p>
  </body>
</html></richcontent>
<node CREATED="1568174253139" ID="ID_908934707" MODIFIED="1568174263138" TEXT="Lookup of each node in the path is O(1)">
<node CREATED="1568174519005" ID="ID_797992579" MODIFIED="1568174523900" TEXT="Un-unifying is not done"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568078160250" ID="ID_1673446595" MODIFIED="1568078164690" TEXT="Code Implementation">
<node CREATED="1568341560514" ID="ID_778191565" MODIFIED="1568344215714" TEXT="find"/>
<node CREATED="1568344221121" ID="ID_554616467" MODIFIED="1568344277207" TEXT="connected"/>
<node CREATED="1568344298893" ID="ID_158909535" MODIFIED="1568344302304" TEXT="componentSize"/>
<node CREATED="1568344303472" ID="ID_1908701638" MODIFIED="1568344306312" TEXT="size"/>
<node CREATED="1568344307559" ID="ID_743386586" MODIFIED="1568344309207" TEXT="components"/>
<node CREATED="1568344332018" ID="ID_854394988" MODIFIED="1568344334194" TEXT="unify"/>
</node>
</node>
</node>
<node CREATED="1567047749513" ID="ID_1062175127" MODIFIED="1567047762257" TEXT="Kruskal&apos;s Algorithm"/>
<node CREATED="1567047763675" ID="ID_1745405641" MODIFIED="1567047768833" TEXT="Union and find operations"/>
<node CREATED="1567047770100" ID="ID_1547770058" MODIFIED="1567047773002" TEXT="Path compression"/>
<node CREATED="1567047773953" ID="ID_330957645" MODIFIED="1567047777977" TEXT="Union find source code"/>
</node>
<node CREATED="1567047783841" ID="ID_1909997002" MODIFIED="1567047788346" POSITION="left" TEXT="Binary search trees">
<node CREATED="1567047790041" ID="ID_238808165" MODIFIED="1567047798747" TEXT="Introduction to binary trees">
<node CREATED="1568528410965" ID="ID_780782571" MODIFIED="1568528417465" TEXT="Outline">
<node CREATED="1568528417876" ID="ID_578273971" MODIFIED="1568528421569" TEXT="Discussion &amp; Examples">
<node CREATED="1568528421793" ID="ID_1507477109" MODIFIED="1568528438410" TEXT="What is a Binary Tree (BT)?"/>
<node CREATED="1568528438738" ID="ID_1040614206" MODIFIED="1568528447812" TEXT="What is a Binary Search Tree (BST)?"/>
<node CREATED="1568528448095" ID="ID_1502420837" MODIFIED="1568528455810" TEXT="Where are BTs and BSTs used?"/>
</node>
<node CREATED="1568528460936" ID="ID_1561418467" MODIFIED="1568528466283" TEXT="Complexity Analysis"/>
<node CREATED="1568528484700" ID="ID_450829794" MODIFIED="1568528489540" TEXT="How to insert nodes into a BST"/>
<node CREATED="1568528489749" ID="ID_781519944" MODIFIED="1568528499334" TEXT="Now to remove nodes from a BST"/>
<node CREATED="1568528499560" ID="ID_346963154" MODIFIED="1568528504846" TEXT="Binary tree traversals">
<node CREATED="1568528505527" ID="ID_1225782092" MODIFIED="1568528507830" TEXT="preorder"/>
<node CREATED="1568528508157" ID="ID_1769320940" MODIFIED="1568528509583" TEXT="inorder"/>
<node CREATED="1568528509823" ID="ID_608449963" MODIFIED="1568528512014" TEXT="postorder"/>
<node CREATED="1568528512236" ID="ID_497748654" MODIFIED="1568528517039" TEXT="level order"/>
</node>
<node CREATED="1568528532840" ID="ID_985303800" MODIFIED="1568528539518" TEXT="A glance at some source code"/>
</node>
<node CREATED="1568528551464" ID="ID_1136244000" MODIFIED="1568528558002" TEXT="Discussion and Examples">
<node CREATED="1568528558899" ID="ID_392043351" MODIFIED="1568528565602" TEXT="Quick terminology crash course">
<node CREATED="1568528566257" ID="ID_1070881785" MODIFIED="1568528581451" TEXT="A tree is an undirected graph which satisfies any of the following definitions:">
<node CREATED="1568528584779" ID="ID_1018793476" MODIFIED="1568528596458" TEXT="An acyclic connected graph"/>
<node CREATED="1568528597299" ID="ID_914039256" MODIFIED="1568528606506" TEXT="A connected graph with N nodes and N - 1 edges"/>
<node CREATED="1568528608413" ID="ID_696876704" MODIFIED="1568528623142" TEXT="A graph in which any two vertices are connected by exactly one path">
<node CREATED="1568528641306" ID="ID_563620070" MODIFIED="1568528649448" TEXT="Cannot have multiple paths - cycle"/>
</node>
</node>
<node CREATED="1568528660099" ID="ID_1665752564" MODIFIED="1568528662658" TEXT="Root node">
<node CREATED="1568528663297" ID="ID_963479124" MODIFIED="1568528680426" TEXT="If we have a rooted tree then we will want to have a reference to the root nodes of our tree">
<node CREATED="1568528680876" ID="ID_1766789195" MODIFIED="1568528686745" TEXT="Any node can be a root"/>
</node>
<node CREATED="1568528691513" ID="ID_1063739012" MODIFIED="1568528712675" TEXT="It does not always matter which node is selected to be the root node because any node can root the tree!"/>
</node>
<node CREATED="1568528721178" ID="ID_363931902" MODIFIED="1568528727683" TEXT="Child node">
<node CREATED="1568528727940" ID="ID_1104977958" MODIFIED="1568528744835" TEXT="A child is a node extending from another node. A parent is the inverse of this">
<node CREATED="1568528751543" ID="ID_665242293" MODIFIED="1568528762168" TEXT="parent is a node from with child node(s) extend"/>
</node>
<node CREATED="1568528768762" ID="ID_35594316" MODIFIED="1568528774414" TEXT="What is the parent of the root node?">
<node CREATED="1568528785645" ID="ID_45805256" MODIFIED="1568528814500" TEXT="It has no parent, although it may be useful to assign the parent of the root node to be itself (e.g. filesystem tree).">
<node CREATED="1568528893778" ID="ID_825186751" MODIFIED="1568528904454" TEXT="cd /; cd ../ (outputs /)"/>
</node>
</node>
</node>
<node CREATED="1568528946339" ID="ID_1192297905" MODIFIED="1568528950909" TEXT="Leaf node">
<node CREATED="1568528952694" ID="ID_1968705732" MODIFIED="1568528966636" TEXT="A leaf node is a node with no children. These have been highlighted in orange"/>
</node>
<node CREATED="1568528972663" ID="ID_364296601" MODIFIED="1568528976181" TEXT="Subtree">
<node CREATED="1568528976519" ID="ID_162904226" MODIFIED="1568529000423" TEXT="A subtree is a tree entirely contained within another. They are usually denoted using triangles."/>
<node CREATED="1568529002931" ID="ID_611349863" MODIFIED="1568529013407" TEXT="Note: Subtrees may consist of a single node!"/>
</node>
</node>
<node CREATED="1568528917531" ID="ID_243235990" MODIFIED="1568528919285" TEXT="Example">
<node CREATED="1568528919845" ID="ID_1387744272" MODIFIED="1568528937477" TEXT="0 has two children (3 and 2) and a parent (4)"/>
</node>
</node>
<node CREATED="1568529069731" ID="ID_1104146040" MODIFIED="1568529075806" TEXT="What is a Binary Tree (BT)?">
<node CREATED="1568529076964" ID="ID_1928735510" MODIFIED="1568529088580" TEXT="A binary tree is a tree for which every node has at most two child nodes."/>
</node>
<node CREATED="1568529163530" ID="ID_712947060" MODIFIED="1568529171251" TEXT="What is a Binary Search Tree (BST)?">
<node CREATED="1568529173551" ID="ID_550492167" MODIFIED="1568529195671" TEXT="A binary search tree is a binary tree that satisfies the BST invariant:">
<node CREATED="1568529195980" ID="ID_1799467676" MODIFIED="1568529212592" TEXT="left subtree has smaller elements and right subtree has larger elements">
<node CREATED="1568529254027" ID="ID_1472785313" MODIFIED="1568529255514" TEXT="example">
<node CREATED="1568529256050" ID="ID_155857854" MODIFIED="1568529271730" TEXT="If duplicate values are allowed">
<node CREATED="1568529271971" ID="ID_1366662400" MODIFIED="1568529281363" TEXT="BST operations allow for duplicate values"/>
<node CREATED="1568529286576" ID="ID_74660265" MODIFIED="1568529306490" TEXT="most of the time we are only interested in having unique elements inside our tree"/>
</node>
<node CREATED="1568529358673" ID="ID_421120445" MODIFIED="1568529365243" TEXT="We are not limited to only numbers">
<node CREATED="1568529365501" ID="ID_1676286024" MODIFIED="1568529371988" TEXT="Any element that is comparable"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568529534059" ID="ID_656168981" MODIFIED="1568529541409" TEXT="When and where are Binary Trees used?">
<node CREATED="1568529541632" ID="ID_1575863214" MODIFIED="1568529548615" TEXT="Binary Search Trees (BSTs)">
<node CREATED="1568529549416" ID="ID_336043989" MODIFIED="1568529557702" TEXT="Implementation of some map and set ADTs"/>
<node CREATED="1568529559312" ID="ID_1174279347" MODIFIED="1568529562559" TEXT="Red Black Trees"/>
<node CREATED="1568529563820" ID="ID_1406217836" MODIFIED="1568529566479" TEXT="AVL Trees">
<node CREATED="1568529664169" ID="ID_1326705468" MODIFIED="1568529666881" TEXT="Balanced"/>
</node>
<node CREATED="1568529567332" ID="ID_900882476" MODIFIED="1568529569567" TEXT="Splay Trees"/>
<node CREATED="1568529570349" ID="ID_117773364" MODIFIED="1568529571375" TEXT="..."/>
</node>
<node CREATED="1568529587802" ID="ID_1020963841" MODIFIED="1568529593976" TEXT="Used in the implementation of binary heaps"/>
<node CREATED="1568529597182" ID="ID_1529026995" MODIFIED="1568529607373" TEXT="Syntax trees (used by compiler and calculators)">
<node CREATED="1568529674034" ID="ID_1334765232" MODIFIED="1568529679930" TEXT="Parsing arithmetic expression">
<node CREATED="1568529680635" ID="ID_55681848" MODIFIED="1568529687602" TEXT="Place in abstract syntax tree"/>
</node>
</node>
<node CREATED="1568529608211" ID="ID_469372867" MODIFIED="1568529620357" TEXT="Treap - a probabilistic DS (uses a randomized BST)"/>
</node>
<node CREATED="1568529713086" ID="ID_772814655" MODIFIED="1568529718519" TEXT="Complexity of BSTs">
<node CREATED="1568529718827" ID="ID_958549267" MODIFIED="1568529723007" TEXT="insert">
<node CREATED="1568529723719" ID="ID_944966390" MODIFIED="1568529726398" TEXT="O(log(n))">
<node CREATED="1568529733720" ID="ID_781705651" MODIFIED="1568529739222" TEXT="Average time complexity"/>
</node>
<node CREATED="1568529762351" ID="ID_63214156" MODIFIED="1568529765744" TEXT="O(n)">
<node CREATED="1568529766056" ID="ID_533105012" MODIFIED="1568529769488" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529727451" ID="ID_1386661459" MODIFIED="1568529729271" TEXT="delete">
<node CREATED="1568529729525" ID="ID_217110308" MODIFIED="1568529732927" TEXT="O(log(n))"/>
<node CREATED="1568529770857" ID="ID_443271952" MODIFIED="1568529773072" TEXT="O(n)">
<node CREATED="1568529773402" ID="ID_1720428557" MODIFIED="1568529776183" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529744576" ID="ID_1381137061" MODIFIED="1568529746022" TEXT="remove">
<node CREATED="1568529746409" ID="ID_853206873" MODIFIED="1568529749551" TEXT="O(log(n))"/>
<node CREATED="1568529782167" ID="ID_1342630894" MODIFIED="1568529783967" TEXT="O(n)">
<node CREATED="1568529784607" ID="ID_970857815" MODIFIED="1568529786495" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529750486" ID="ID_3004114" MODIFIED="1568529751968" TEXT="search">
<node CREATED="1568529752214" ID="ID_826174695" MODIFIED="1568529754848" TEXT="O(log(n))"/>
<node CREATED="1568529788941" ID="ID_1506658700" MODIFIED="1568529790344" TEXT="O(n)">
<node CREATED="1568529790656" ID="ID_648847970" MODIFIED="1568529792392" TEXT="Worst case"/>
</node>
</node>
</node>
</node>
<node CREATED="1567047799767" ID="ID_1131461627" MODIFIED="1567047805635" TEXT="Binary search tree insertions">
<node CREATED="1568573922905" ID="ID_1927978971" MODIFIED="1568573928595" TEXT="Adding elements to a BST">
<node CREATED="1568573930118" ID="ID_735363289" MODIFIED="1568573947507" TEXT="Binary Search Tree (BST) elements must be comparable so that we cannot order them inside the tree"/>
<node CREATED="1568573952458" ID="ID_386134655" MODIFIED="1568573982965" TEXT="When inserting an element we want to compare its value to the value stored in the current node we&apos;re considering to decide on one of the following:">
<node CREATED="1568573995110" ID="ID_1576644693" MODIFIED="1568574008270" TEXT="Recurse down left subtree (&lt; case)"/>
<node CREATED="1568574008619" ID="ID_1088655444" MODIFIED="1568574019312" TEXT="Recurse down right subtree (&gt; case)"/>
<node CREATED="1568574019823" ID="ID_42389156" MODIFIED="1568574028758" TEXT="Handle finding a duplicate value (= case)">
<node CREATED="1568574218414" ID="ID_1727983030" MODIFIED="1568574222954" TEXT="Add duplicate or ignore">
<node CREATED="1568574353241" ID="ID_1124764950" MODIFIED="1568574361299" TEXT="Choose either left or right and insert"/>
</node>
</node>
<node CREATED="1568574030055" ID="ID_772926372" MODIFIED="1568574038158" TEXT="Construct a new node (found a null leaf)">
<node CREATED="1568574242630" ID="ID_1744987440" MODIFIED="1568574246782" TEXT="If null node is hit"/>
</node>
</node>
</node>
<node CREATED="1568574298043" ID="ID_858739085" MODIFIED="1568574304125" TEXT="Start at root when inserting">
<node CREATED="1568574403561" ID="ID_1397051731" MODIFIED="1568574405297" TEXT="Example">
<node CREATED="1568574405540" ID="ID_1504360597" MODIFIED="1568574450401">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      insert(7)
    </p>
    <p>
      insert(20)
    </p>
    <p>
      insert(5)
    </p>
    <p>
      insert(15)
    </p>
    <p>
      insert(10)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(33)
    </p>
    <p>
      insert(2)
    </p>
    <p>
      insert(25)
    </p>
    <p>
      insert(6)
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1568574473084" ID="ID_244751343" MODIFIED="1568574477750" TEXT="Worst case example">
<node CREATED="1568574478041" ID="ID_1232290242" MODIFIED="1568574502930">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      insert(1)
    </p>
    <p>
      insert(2)
    </p>
    <p>
      insert(3)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(5)
    </p>
    <p>
      insert(6)
    </p>
  </body>
</html></richcontent>
<node CREATED="1568574515004" ID="ID_1379986102" MODIFIED="1568574522577" TEXT="takes linear time">
<node CREATED="1568574524690" ID="ID_1077835708" MODIFIED="1568574527121" TEXT="solution">
<node CREATED="1568574527341" ID="ID_555961881" MODIFIED="1568574533558" TEXT="balanced binary search trees"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047806769" ID="ID_1637447282" MODIFIED="1567047811993" TEXT="Binary search tree removals">
<node CREATED="1568680839649" ID="ID_1621802069" MODIFIED="1568680849030" TEXT="Removing elements from a BST">
<node CREATED="1568680849533" ID="ID_448812915" MODIFIED="1568680869400" TEXT="Removing elements from a Binary Search Tree (BST) can be seen as a two step process">
<node CREATED="1568680871295" ID="ID_520092863" MODIFIED="1568681480835">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <ol>
      <li>
        Find the element we wish to remove (if it exists)
      </li>
      <li>
        Replace the node we want to remove with its successor (if any) to maintain the BST invariant.
      </li>
    </ol>
  </body>
</html></richcontent>
<node CREATED="1568681482430" ID="ID_122331550" MODIFIED="1568681500116" TEXT="BST invariant: left subtree has smaller elements and right subtree has larger elements"/>
<node CREATED="1576461481630" ID="ID_63782140" MODIFIED="1576461485399" TEXT="Find Phase">
<node CREATED="1576461486007" ID="ID_14717728" MODIFIED="1576461513854" TEXT="When searching our BST for a node with a particular value one of four things can happen">
<node CREATED="1576461515237" ID="ID_462665047" MODIFIED="1576461528344" TEXT="1. We hit a null node at which point we know the value does not exist within out BST">
<node CREATED="1576461734158" ID="ID_987362887" MODIFIED="1576461738450" TEXT="Value does not exist"/>
</node>
<node CREATED="1576461528588" ID="ID_1746345004" MODIFIED="1576461538734" TEXT="2. Comparator value equal to 0 (found it!)">
<node CREATED="1576461749307" ID="ID_1919631078" MODIFIED="1576461754490" TEXT="comparator()"/>
</node>
<node CREATED="1576461538997" ID="ID_516582642" MODIFIED="1576461557302" TEXT="Comparator value less than 0 (the value, if it exists, is in the left subtree)"/>
<node CREATED="1576461557992" ID="ID_1243458320" MODIFIED="1576461574920" TEXT="4. Comparator value greater than 0 (the value, if it exists, is in the right subtree)"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1569810446966" ID="ID_1888254347" MODIFIED="1569810451066" TEXT="Find phase">
<node CREATED="1569810451308" ID="ID_157612766" MODIFIED="1569810472742" TEXT="When searching our BST for a node with a particular value one of four things will happen:">
<node CREATED="1569810473200" ID="ID_1901590796" MODIFIED="1569810488138" TEXT="1. We hit a null node at which point we know the value does not exist withing our BST"/>
</node>
</node>
<node CREATED="1576461889023" ID="ID_920480280" MODIFIED="1576461893037" TEXT="Remove Phase">
<node CREATED="1576461893947" ID="ID_672362687" MODIFIED="1576461900162" TEXT="Node to remove is a leaf node">
<node CREATED="1576461935351" ID="ID_952482166" MODIFIED="1576461940543" TEXT="Case I: Leaf Node">
<node CREATED="1576461941853" ID="ID_1048945303" MODIFIED="1576461962648" TEXT="If the node we wish to remove is a leaf node then we may do so without side effect"/>
<node CREATED="1576461964016" ID="ID_1095662322" MODIFIED="1576461991210" TEXT="Suppose we want to remove 8 from the BST on the right. First we would find 8 then remove it immediately since it&apos;s a leaf node"/>
</node>
</node>
<node CREATED="1576461900632" ID="ID_661337218" MODIFIED="1576461910025" TEXT="Node to remove has a right subtree but no left subtree">
<node CREATED="1576462015104" ID="ID_1815376648" MODIFIED="1576462027300" TEXT="Case II &amp; III: either the left/right child node is a subtree">
<node CREATED="1576462033764" ID="ID_1275260460" MODIFIED="1576462051005" TEXT="The successor of the node we are trying to remove in these cases will be the root node of the left/right subtree"/>
<node CREATED="1576462063121" ID="ID_1181855354" MODIFIED="1576462087797" TEXT="It may be the case that you are removing the root node of the BST in which case its immediate child becomes the new root as you would expect.">
<node CREATED="1576462955506" ID="ID_51377550" MODIFIED="1576462959628" TEXT="Remove phase">
<node CREATED="1576462960449" ID="ID_359262930" MODIFIED="1576462975971" TEXT="Suppose we wish to remove 9, then we encounter case II with a left subtree">
<node CREATED="1576463013689" ID="ID_1530898959" MODIFIED="1576463023051" TEXT="Replace 9 with left subtree"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576461910236" ID="ID_686947562" MODIFIED="1576461920505" TEXT="Node to remove has a left subtree but no right subtree"/>
<node CREATED="1576461920719" ID="ID_1735541905" MODIFIED="1576461931998" TEXT="Node to remove has a both left subtree and a right subtree">
<node CREATED="1576463067025" ID="ID_1518852286" MODIFIED="1576463079246" TEXT="Case IV: Node to remove has both a left subtree and a right subtee">
<node CREATED="1576463079964" ID="ID_1701814472" MODIFIED="1576463093810" TEXT="Q: In which subtree will the successor of the node we are trying to remove be?">
<node CREATED="1576463100881" ID="ID_363204097" MODIFIED="1576463127343" TEXT="A: The answer is both! The successor can eiher be the largest value is left subtree or the smallest value in the right subtree">
<node CREATED="1576463285961" ID="ID_49461250" MODIFIED="1576463299600" TEXT="A justification for why there could be more than one successor is:">
<node CREATED="1576464632357" ID="ID_439636528" MODIFIED="1576464647152" TEXT="The largest value in the left subtree satisfies the BST invriant since it:">
<node CREATED="1576464648159" ID="ID_1376997341" MODIFIED="1576464678568" TEXT="Is larger than everything in left subtree. This follows immediately from teh deefinition of being the largest."/>
<node CREATED="1576464679281" ID="ID_1008873799" MODIFIED="1576464703032" TEXT="Is smaller than everything in right subtree because it was found in the left subtree"/>
</node>
<node CREATED="1576464738650" ID="ID_1023946656" MODIFIED="1576464754252" TEXT="The smallest value in the righ subtree satsifies the BST invariant since it:">
<node CREATED="1576464754651" ID="ID_98688016" MODIFIED="1576464778292" TEXT="Is smaller than everything in right subtree. This follows immediately from the definition of being the smallest"/>
<node CREATED="1576464778868" ID="ID_897526518" MODIFIED="1576464791442" TEXT="Is larger than everything in left subtree because it was found in teh right subtree"/>
<node CREATED="1576464791901" ID="ID_233235353" MODIFIED="1576464800365" TEXT="So there are two possible successors, yea!"/>
</node>
</node>
<node CREATED="1576464851491" ID="ID_390127912" MODIFIED="1576464856565" TEXT="We can choose either">
<node CREATED="1576464879132" ID="ID_1203013670" MODIFIED="1576464881989" TEXT="Convension">
<node CREATED="1576464934477" ID="ID_598464022" MODIFIED="1576464947202" TEXT="May need to be done recursively">
<node CREATED="1576465024810" ID="ID_350893117" MODIFIED="1576465043623" TEXT="Case I &gt; Case II or Case III &gt; Case IV"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576461808520" ID="ID_1347775802" MODIFIED="1576461811457" TEXT="Example:">
<node CREATED="1576461811897" ID="ID_468406332" MODIFIED="1576461837560">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Find queries:
    </p>
    <p>
      find(14)
    </p>
    <p>
      find(25)
    </p>
    <p>
      find(37)
    </p>
    <p>
      find(17)
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567047812980" ID="ID_194906046" MODIFIED="1567047818554" TEXT="Binary tree traversals">
<node CREATED="1576465288735" ID="ID_1752451947" MODIFIED="1576465299337" TEXT="Preorder, Inorder, Postorder &amp; Level order">
<node CREATED="1576465737369" ID="ID_1389316316" MODIFIED="1576465746420" TEXT="Recursively defined">
<node CREATED="1576465746789" ID="ID_1867325297" MODIFIED="1576465795464">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      preorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;preorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;preorder(node.right)
    </p>
    <p>
      &#160;&#160;&#160;
    </p>
  </body>
</html></richcontent>
<node CREATED="1576465974504" ID="ID_1798276195" MODIFIED="1576465981728" TEXT="preorder prints before the recursive calls"/>
</node>
<node CREATED="1576465882978" ID="ID_224051724" MODIFIED="1576465927189">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      inorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;inorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;inorder(node.right)
    </p>
  </body>
</html></richcontent>
<node CREATED="1576466616583" ID="ID_1537868948" MODIFIED="1576466625668" TEXT="inorder prints between the recursive calls"/>
</node>
<node CREATED="1576465930831" ID="ID_1557013778" MODIFIED="1576465968941">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      postorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;postorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;postorder(node.right)
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
  </body>
</html></richcontent>
<node CREATED="1576466626823" ID="ID_558349930" MODIFIED="1576466637195" TEXT="postorder prints after the recursive calls">
<node CREATED="1576467243398" ID="ID_655833740" MODIFIED="1576467372771">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Call Stack:
    </p>
    <p>
      node A
    </p>
    <p>
      node B
    </p>
    <p>
      node D
    </p>
    <p>
      node I
    </p>
    <p>
      
    </p>
    <p>
      Order: A, B, D, H, I&#160;
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576551909520" ID="ID_1037845328" MODIFIED="1576551914682" TEXT="Inorder traversal">
<node CREATED="1576551915071" ID="ID_1938042881" MODIFIED="1576551930345" TEXT="Prints values in-order - increasing order"/>
</node>
</node>
<node CREATED="1576552049869" ID="ID_1575590025" MODIFIED="1576552056798" TEXT="Level Order Traversal">
<node CREATED="1576552058767" ID="ID_767845064" MODIFIED="1576552072362" TEXT="In a level order traversal we want to print the nodes as they appear one layer at a time">
<node CREATED="1576552101378" ID="ID_1666245098" MODIFIED="1576552116284" TEXT="To obtain this ordering we want to do a BFS from the root node down to the leaf nodes">
<node CREATED="1576552123896" ID="ID_1589099867" MODIFIED="1576552137587" TEXT="To do a BFS we will need to maintain a Queue of the nodes left to explore"/>
<node CREATED="1576552139032" ID="ID_1074244951" MODIFIED="1576552170747" TEXT="Begin with the root inside of the queue and finish when the queue is empty">
<node CREATED="1576552180219" ID="ID_10089081" MODIFIED="1576552203862" TEXT="Steps: At each iteration we add the left child and the right child of the current node to our queue"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047819640" ID="ID_600226500" MODIFIED="1567047827032" TEXT="Binary search tree source code">
<node CREATED="1576552408502" ID="ID_1963818458" MODIFIED="1576594782743">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      <font size="1">public class BinarySearchTree &lt;T extends Comparable&lt;T&gt;&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Tracks the number of nodes in this BST </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int nodeCount = 0; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// This BST is a rooted tree so we maintain a handle on the root node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private Node root = null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Internal node containing node references </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// and the actual node data </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private class Node { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T data; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node left, right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public Node (Node left, Node right, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.data = elem; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.left = left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.right = right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Check if this binary tree is empty </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean isEmpty() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return size() == 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Get the number of nodes in this binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public int size() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return nodeCount; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Add an element to this binary tree. Returns true </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// if we successfully perform an insertion </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean add(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Check if the value already exists in this </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// binary tree, if it does ignore adding it </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (contains(elem)) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false; </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Otherwise add this element to the binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = add(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nodeCount++; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Private method to recursively add a value in the binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node add(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Base case: found a leaf node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = new Node(null, null, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Place lower elements values in left subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (elem.compareTo(node.data) &lt; 0) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.left = add(node.left, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = add(node.right, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Remove a value from this binary tree, if it exists </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public boolean remove(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Make sure the node we want to remove </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// actually exists before we remove it </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (contains(elem)) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = remove(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nodeCount--; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node remove(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int cmp = elem.compareTo(node.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into left subtree, the value we're looking </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for is smaller than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmp &lt; 0) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.left = remove(node.left, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into right subtree, the value we're looking </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for is greater than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (cmp &gt; 0) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = remove(node.right, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Found the node we wish to remove </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This is the case with only a right subtree or </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no subtree at all. In this situation just </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// swap the node we wish to remove with its right child. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node.left == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node rightChild = node.right; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = null; </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return rightChild; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This is the case with only a left subtree or </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no subtree at all. In this situation just </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// swap the node we wish to remove with its left child. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (node.right == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node leftChild = node.left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return leftChild; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// When removing a node from a binary tree with two links th </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// successor of the node being removed can either be the largest </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// value in the left subtree or the smallest value in the right </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// subtree. In this implementation I have decided to find the </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// smallest value in the right subtree which can be found by </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// traversing as far as possible in the right subtree. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Find the leftmost node in the right subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node tmp = digLeft(node.right); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Swap the data </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = tmp.data; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Go into the right subtree and remove the leftmost node we </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// found and swapped data with. This prevents us from having </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// two nodes in our tree with the same value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = remove(node.right, tmp.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// If instead we wanted to find the largest node in the left </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// subtree as opposed to smallest node in the right subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// here is what we do: </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Node tmp = digRight(node.left); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// node.data = tmp.data; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// node.left = remove(node.left, tmp.data);&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Helper method to find the leftmost node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node digLeft(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node cur = node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cur.left != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur = cur.left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return cur; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Helper method to find the leftmost node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node digRight(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node cur = node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cur.right != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur = cur.right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return cur; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// returns true if the element exists in the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public boolean contains(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return contains(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// private recursive method to find an element in the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private boolean contains(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Base case: reached bottom, value not found </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return false; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int cmp = elem.compareTo(node.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into the left subtree because the value we're </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// looking for is smaller than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmp &lt; 0) return contains(node.left, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into the right subtree because the value we're </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// looking for is greater than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (cmp &gt; 0) return contains(node.right, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// We found the value we were looking for </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Computes the height of the tree, O(n) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public int height() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return height(root); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Recursive helper method to compute the height of the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private int height(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Math.max(height(node.left), height(node.right)) + 1; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This method returns an iterator for a given TreeTraversalOrder. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// The ways in which you can traverse the tree are four different ways </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// preorder, inorder, postorder and levelorder. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public java.util.Iterator &lt;T&gt; traverse(TreeTraversalOrder order) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (order) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case PRE_ORDER: return preOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case IN_ORDER: return inOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case POST_ORDER: return postOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case LEVEL_ORDER: return levelOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Returns as iterator to traverse the tree in pre order </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private java.util.Iterator &lt;T&gt; preOrderTraversal() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;}</font>
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567047834200" ID="ID_1076354860" MODIFIED="1567047836627" POSITION="right" TEXT="Hash tables">
<node CREATED="1567047838699" ID="ID_498331933" MODIFIED="1567047843888" TEXT="Hash table hash functions">
<node CREATED="1576719071204" ID="ID_1737571070" MODIFIED="1576719391418">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Outline
    </p>
    <ol>
      <li>
        What is a Hash Table (HT) and what is a hash function?
      </li>
      <li>
        Properties of hash functions
      </li>
      <li>
        Discussion on collision resolution methods, in particular: separate chaining and open addressing
      </li>
      <li>
        Complexity analysis
      </li>
      <li>
        Separate chaining implementation details:

        <ol>
          <li>
            Linked list approach overview
          </li>
          <li>
            Separate chaining FAQs
          </li>
          <li>
            Separate chaining source code
          </li>
        </ol>
      </li>
      <li>
        Separate chaining HT source code
      </li>
      <li>
        Open addressing techniques implementation details:

        <ol>
          <li>
            Linear probing

            <ol>
              <li>
                What is linear probing?
              </li>
              <li>
                Chaos with cycles
              </li>
              <li>
                Linear probing insertion examples
              </li>
              <li>
                Table resizing and updating values
              </li>
            </ol>
          </li>
          <li>
            Quadratic probing

            <ol>
              <li>
                What is quadratic probing?
              </li>
              <li>
                Problems with probing sequence cycles
              </li>
              <li>
                Different ways to quadratically probe
              </li>
              <li>
                Inserting/ resize examples
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        Double hashing

        <ol>
          <li>
            What is double hashing? How does it work?
          </li>
          <li>
            Chaos with cycles
          </li>
          <li>
            Constructing a new hash function

            <ol>
              <li>
                Universal hash functions
              </li>
            </ol>
          </li>
          <li>
            Inserting/ resize example
          </li>
        </ol>
      </li>
      <li>
        Removing elements

        <ol>
          <li>
            Solution using tomstones
          </li>
          <li>
            Lazy deletion/ relocation
          </li>
          <li>
            Lots of examples
          </li>
        </ol>
      </li>
      <li>
        Source code!
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node CREATED="1576719409990" ID="ID_1774369679" MODIFIED="1576719416996" TEXT="What is a hash table?">
<node CREATED="1576719417243" ID="ID_1459234231" MODIFIED="1576719441447" TEXT="A hash table (HT) is a data structure that provides a mapping from keys to values using a technique calling hashing.">
<node CREATED="1576719481432" ID="ID_1442243528" MODIFIED="1576719537337">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      key (name) -&gt; value (fav color)
    </p>
    <p>
      &quot;William&quot; -&gt; &quot;green&quot;
    </p>
    <p>
      &quot;Micah&quot; -&gt; &quot;purple&quot;
    </p>
    <p>
      &quot;Catherine&quot; -&gt; &quot;yellow&quot;
    </p>
    <p>
      &quot;Thomas&quot; -&gt; &quot;red&quot;
    </p>
    <p>
      &quot;Leah&quot; -&gt; &quot;purple&quot;
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576719542482" ID="ID_353482957" MODIFIED="1576719549546" TEXT="We refer to these as key-value pairs"/>
<node CREATED="1576719550849" ID="ID_928593708" MODIFIED="1576719560671" TEXT="Keys must be unique, but values can be repeated"/>
<node CREATED="1576719592181" ID="ID_590492122" MODIFIED="1576719615250" TEXT="HTs are often used to track item frequencies. For instance, coutning the number of times a word appears in a given text."/>
<node CREATED="1576719667099" ID="ID_1449510494" MODIFIED="1576719697130" TEXT="The key-value pairs you can place in a HT can be of any type not just strings and numbers, but also bojects! However, the keys needs to be hashable, a property we will discuss shortly">
<node CREATED="1576719707058" ID="ID_873018824" MODIFIED="1576719732321" TEXT="To be able to understand how a mapping is constructed between key-value pairs we fist need to talk about hash functions."/>
<node CREATED="1576719732567" ID="ID_1959597115" MODIFIED="1576719747809" TEXT="A hash function H(x) is a function that maps a key &apos;x&apos; to a whole number in a fixed range.">
<node CREATED="1576719751627" ID="ID_1160981104" MODIFIED="1576719786554" TEXT="Example: H(x) = (x^2 - 6x + 9) mod 10 maps all integer keys to the range [0, 9]">
<node CREATED="1576719794298" ID="ID_1324821729" MODIFIED="1576719938680">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      H(4) = (16 - 24 + 9) mod 10 = 1
    </p>
    <p>
      H(-7) = (49 + 42 + 9) mod 10 = 0
    </p>
    <p>
      H(0) = (0 - 0 + 9) mod 10 = 9
    </p>
    <p>
      H(2) = (4 - 12 + 9) mod 10 = 1
    </p>
    <p>
      H(8) = (64 - 48 + 9) mod 10 = 5
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576719981847" ID="ID_324076642" MODIFIED="1576720006195" TEXT="We can also define hash functions for arbitrary objects such as strings, list, tuples, multi data objects, etc...">
<node CREATED="1576720017235" ID="ID_260903345" MODIFIED="1576720037487" TEXT="For a string s let H(s) be a hash function defined below where ASCII(x) returns the ASCII valeu fo the character x">
<node CREATED="1576720040853" ID="ID_881056835" MODIFIED="1576720077379">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      ASCII('A') = 65
    </p>
    <p>
      ASCII('B') = 66
    </p>
    <p>
      ...
    </p>
    <p>
      ASCII('Z') = 90
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1576720080138" ID="ID_309025568" MODIFIED="1576720129560">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function H(s):
    </p>
    <p>
      &#160;&#160;&#160;&#160;sum := 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;for char in x:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum = sum + ASCII(char)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return sum mod 50
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1576720271210" ID="ID_1995836199" MODIFIED="1576720289259" TEXT="There are an infinite number of possible valid hash functions H(person), here is one:">
<node CREATED="1576720290849" ID="ID_1284309586" MODIFIED="1576720340812">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function H(person):
    </p>
    <p>
      &#160;&#160;&#160;&#160;hash := person.age
    </p>
    <p>
      &#160;&#160;&#160;&#160;hash = hash + length(person.name)
    </p>
    <p>
      &#160;&#160;&#160;&#160;if person.sex == &quot;M&quot;:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash = hash + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;return hash mod 6
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576720397304" ID="ID_585727740" MODIFIED="1576720403401" TEXT="Properties of Hash functions">
<node CREATED="1576720403810" ID="ID_146175552" MODIFIED="1576720434098" TEXT="If H(x) = H(y) then objects x and y might be equal, but if H(x) != H(y) then x and y are certainly not equal">
<node CREATED="1576720484417" ID="ID_680162370" MODIFIED="1576720497064" TEXT="Q: How can we use this to our advantage to speedup object comparisons?">
<node CREATED="1576720505225" ID="ID_1898076730" MODIFIED="1576720538716" TEXT="A: This means that instead of comparing x and y directly a smarter approach is to first compare their hash values, and only if the hash values match do we nedd to explicitly compare xa nd y."/>
<node CREATED="1576721967580" ID="ID_304807664" MODIFIED="1576721987476" TEXT="Consider the problem of trying to determine if two very large files have the same contents."/>
<node CREATED="1576721987977" ID="ID_643451174" MODIFIED="1576722066926" TEXT="If we precomputed H(file1) and H(file2) first we should compare those hash values since comparing hash values is O(1)! If possible, we do not want to open either of the files directly. Comparing their contents can be very slow, although we may have to if H(file1) = H(file2).">
<node CREATED="1576722069556" ID="ID_638934834" MODIFIED="1576722103324" TEXT="NOTE: Hash functions for files are more sophisticated than those used for hashtables. Instead for files we use what are called cryptographic hash functions also called checksums"/>
</node>
<node CREATED="1576722202495" ID="ID_1558704010" MODIFIED="1576722213024" TEXT="A hash function H(x) must be deterministic.">
<node CREATED="1576722214705" ID="ID_1807800955" MODIFIED="1576722254468" TEXT="This means that if H(x) = y then H9x) must always produce y and never another value.. This may be seen as obvious, but it is critical to the functionality of a hash function.">
<node CREATED="1576722259505" ID="ID_923968337" MODIFIED="1576722270754" TEXT="Example of non-deterministic hash functions:">
<node CREATED="1576722271010" ID="ID_1309489189" MODIFIED="1576722298798">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      counter := 0
    </p>
    <p>
      function H(x):
    </p>
    <p>
      &#160;&#160;&#160;&#160;counter = counter + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;return (x + counter) mod 13
    </p>
  </body>
</html></richcontent>
<node CREATED="1576722300228" ID="ID_1536661597" MODIFIED="1576722324692" TEXT="H(5) = 6 but H(5) = 7 as well"/>
</node>
</node>
</node>
</node>
<node CREATED="1576722345718" ID="ID_312245411" MODIFIED="1576722362549" TEXT="We try very hard to make uniform hash functions to minize the number of hash collisions">
<node CREATED="1576722364211" ID="ID_1200506814" MODIFIED="1576722424166" TEXT="A hash collision is when two objects, x, y hash to the same value (i.e. H(x) = H(y))."/>
</node>
<node CREATED="1576722434295" ID="ID_63759049" MODIFIED="1576722462536" TEXT="We are now able to answer a central question about the types of keys we are allowed to use in our hashtable:">
<node CREATED="1576722462528" ID="ID_1842837840" MODIFIED="1576722488238" TEXT="Q: What makes a key of type T hashable?">
<node CREATED="1576722503030" ID="ID_1267467075" MODIFIED="1576722583249" TEXT="A: Since we are going to use hash functions in the implementation of our hash table we need our hash functions to be deterministic. To enforce this behaviour, we demand that the keys used in our hashtable are immutable data types. Hence, if a key fof type T is immutable, and we have a hash function H(k) defined for all keys k of type T then we say a key of type T is hashable.">
<node CREATED="1576722609396" ID="ID_1217280733" MODIFIED="1576722620144" TEXT="keys are immutable - strings, integers">
<node CREATED="1576722621850" ID="ID_370951750" MODIFIED="1576722630456" TEXT="Not sets or lists"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576722651007" ID="ID_523341002" MODIFIED="1576722656249" TEXT="How does a hash table work?">
<node CREATED="1576722659577" ID="ID_1534945728" MODIFIED="1576722679268" TEXT="Ideally we would like to have a very fast insertion, lookup and removal time for the data we are placing withing our hash table.">
<node CREATED="1576722744298" ID="ID_1247451831" MODIFIED="1576722754748" TEXT="Hash table is an array"/>
</node>
<node CREATED="1576722681238" ID="ID_505334372" MODIFIED="1576722705640" TEXT="Remarkably, we can achieve all this in O(1)* time using a hash function as a way to index into a hash table."/>
<node CREATED="1576722706750" ID="ID_574578431" MODIFIED="1576722726279" TEXT="* The constant time behaviour attributed to hash tables is only true if you have a good uniform hash function!"/>
<node CREATED="1576722787934" ID="ID_923768759" MODIFIED="1576722860059" TEXT="Think of the hash table on the right as an indexable block of memory (an array) and we can only access its entries using the value given to us by our hash function H(x)">
<node CREATED="1576723195754" ID="ID_791924647" MODIFIED="1576723243518" TEXT="Suppose we&apos;re inserting (integer, string) key-value pairs into teh table representing rankings of users to their usernames from an outline programming competition and we&apos;re using the hash function: H(x) = x^2 + 3 mod 10"/>
<node CREATED="1576723372256" ID="ID_1611902482" MODIFIED="1576723388217" TEXT="To lookup which user has rank r we simply compute H(f) and look inside the hashtable!"/>
</node>
<node CREATED="1576723400565" ID="ID_225952506" MODIFIED="1576723414922" TEXT="Q: What do we do if there is a hash collision?">
<node CREATED="1576723415408" ID="ID_1998476299" MODIFIED="1576723433414" TEXT="example: users with ranks 2 and 8 hash to the same value!!">
<node CREATED="1576723435059" ID="ID_477005514" MODIFIED="1576723454750" TEXT="H(2) = 2^2 + 3 mod 10 = 7 = 8^2 + 3 mod 10 = H(8)"/>
</node>
<node CREATED="1576723462070" ID="ID_1325438972" MODIFIED="1576723484930" TEXT="A: We use one of many hash collision resolution techniques to handle this, the two most popular ones are separate chaining and open addressing.">
<node CREATED="1576723500813" ID="ID_1405068280" MODIFIED="1576723553551" TEXT="Separate chaining deals with hash collisions by maintaining a data structure (usually a linked lis) to hold all the different values which hashed to a particular value."/>
<node CREATED="1576723554852" ID="ID_1904581245" MODIFIED="1576723596395" TEXT="Open addressing deals with hash collisions by finding place within the hash table for the object to go by offsetting it from the position to which it hashed to.">
<node CREATED="1576724661973" ID="ID_1478893207" MODIFIED="1576724665640" TEXT="Complexity:">
<node CREATED="1576724666247" ID="ID_1938104579" MODIFIED="1576724680568" TEXT="Insertion: Average - O(1)*, Wors - O(n)">
<node CREATED="1576724721965" ID="ID_172618407" MODIFIED="1576724745039" TEXT="* The constant time behavior attributed to hash tables is only true if you have agood uniform hash function!"/>
</node>
<node CREATED="1576724681231" ID="ID_1892088286" MODIFIED="1576724693824" TEXT="Removal: Average - O(1)*, Words - O(n)"/>
<node CREATED="1576724694561" ID="ID_1689831060" MODIFIED="1576724706600" TEXT="Search: Average - O(1)*, Worst - O(n)"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047845106" ID="ID_1637573432" MODIFIED="1567047851822" TEXT="Hash table separate chaining">
<node CREATED="1576726287665" ID="ID_1210949899" MODIFIED="1576726293186" TEXT="What is seperate chaining?">
<node CREATED="1576726293449" ID="ID_1062890330" MODIFIED="1576726331086" TEXT="Separate chaining is one of many strategiesto deal with hash collisions by maintaining a data strcuture (susually a linked list) to hold all the different values which hashed to a particular value.">
<node CREATED="1576726349314" ID="ID_70905475" MODIFIED="1576726355241" TEXT="Auxiliary data structure is used"/>
<node CREATED="1576726361987" ID="ID_1045936607" MODIFIED="1576726414027" TEXT="NOTE: The data structures used to cache the itemsused to cache the items which hashed to a particular value is not limited to a linked list. Some implemenatations use one or a mixture of: arrays, binary trees, self balancing trees and etc..."/>
</node>
<node CREATED="1576726547031" ID="ID_1776349136" MODIFIED="1576726556199" TEXT="Linked list separate chaining insertions">
<node CREATED="1576726557198" ID="ID_1720991584" MODIFIED="1576726578151" TEXT="Suppose we have a hash table that will store (name, age) key-value pairs and we wish to insert the following entries:">
<node CREATED="1576726837929" ID="ID_764009300" MODIFIED="1576726867602" TEXT="NOTE: Even if values are same, we store the key (name) value in the linked list block"/>
</node>
</node>
<node CREATED="1576726900360" ID="ID_366364213" MODIFIED="1576726904630" TEXT="Lookups">
<node CREATED="1576726907862" ID="ID_1406857671" MODIFIED="1576726930087" TEXT="To find the age of &quot;Ryan&quot; hash the key &quot;Ryan&quot; to obtain the value (index) 1. After this search teh 1 bucket for &quot;Ryan&quot;"/>
</node>
</node>
<node CREATED="1576727220861" ID="ID_1968344896" MODIFIED="1576727222951" TEXT="FAQs">
<node CREATED="1576727223153" ID="ID_852034882" MODIFIED="1576727249203" TEXT="Q: How do I maintain O(1) insertion and lookup time complexity once my HT gets really full and I have long linked list chains?">
<node CREATED="1576727250093" ID="ID_1297423091" MODIFIED="1576727284359" TEXT="A: Once the HT contains a lot of elements you should construct a new HT with a larger capacilty and rehash all the items inside the old HT and disperse them throughout the new HT ant different locations."/>
</node>
<node CREATED="1576727341227" ID="ID_1599242919" MODIFIED="1576727349145" TEXT="Q: How do I remove key-value pairs from my HT?">
<node CREATED="1576727349716" ID="ID_1202443782" MODIFIED="1576727391118" TEXT="A: Apply the same procedure as doing a lookup for a key, but this time instead of returning the value associated with the key remove the node in the linked list data structure."/>
</node>
<node CREATED="1576727401488" ID="ID_1609089780" MODIFIED="1576727418574" TEXT="Q: Can I use another data structure to model the bucket behaviour required for the sepaarate chaining method?">
<node CREATED="1576727421100" ID="ID_341353060" MODIFIED="1576727489445" TEXT="A: Of course! Common data structures used instead of a linked list include: arrays, binary trees, self balancing trees, etc... You can even go with a hybrid approach like Java&apos;s HashMap. However, note that some of these are much more memory intensive and complext to implement than a simple linked list which is why they may be less popular">
<node CREATED="1576727514527" ID="ID_438463014" MODIFIED="1576727534999" TEXT="Jaa switches t oa binary tree once the length gets to certain point"/>
<node CREATED="1576727558925" ID="ID_239823131" MODIFIED="1576727562723" TEXT="They might be faster"/>
</node>
</node>
</node>
</node>
<node CREATED="1567047852767" ID="ID_1781810660" MODIFIED="1567047861859" TEXT="Hash table separate chaining source code">
<node CREATED="1577334212789" ID="ID_1039092499" MODIFIED="1577369364567">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      <font size="1">class Entry &lt;K, V&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;int hash; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;K key; V value; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public Entry(K key, V value) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.key = key; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.value = value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.hash = key.hashCode(); // cache to not recompute </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// We are not overriding the Object equals method </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// No casting is required with this method. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean equals(Entry &lt;K, V&gt; other) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (hash != other.hash) return false; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return key.equals(other.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;@Override public String toString() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return key + &quot; =&gt; &quot; + value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">@SuppressWarnings(&quot;unchecked&quot;) </font>
    </p>
    <p>
      <font size="1">public class HashTableSeparateChaining &lt;K, V&gt; implements Iterable &lt;K&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private static final int DEFAULT_CAPACITY = 3; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private static final double DEFAULT_LOAD_FACTOR = 0.75; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private double maxLoadFactor; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int capacity, threshold, size = 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private LinkedList &lt;Entry&lt;K,V&gt;&gt; [] table; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public HashTableSeperateChaining () { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;}&#160; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public HashTableSeperateChaining (int capacity, double maxLoadFactor) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (capacity &lt; 0) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw new IllegalArgumentException(&quot;Illegal capacity&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (maxLoadFactor &lt;= 0 || Double.isNaN(maxLoadFactor) || Double.isInfinite(maxLoadFactor)) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw new IllegalArgumentException(&quot;Illegal maxLoadFactor&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.maxLoadFactor = maxLoadFactor; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.capacity = capacity; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;threshold = (int) (this.capacity * maxLoadFactor); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table = new LinkedList[this.capacity]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the number of elements currently inside the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public int size() { return size; } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns true/false depending on whether the hash-table is empty </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean isEmpty() { return size == 0; } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Converts a hash value to an index. Essentially, this strips the </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// negative sign and places the hash value in the domain [0, capacity) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int normalizeIndex(int keyHash) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return (keyHash &amp; 0x7FFFFFFF) % capacity; // strips negative sign </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Clears all the contents of the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public void clear() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Arrays.fill(table, null); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size = 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean containsKey(K key) { return hasKey(key); } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns true/false depending on whether a key is in the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean hasKey(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketSeekEntry(bucketIndex, key) != null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Insert, put and add all place a value in the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V put(K key, V value) { return insert(key, value); } </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V add(K key, V value) { return insert(key, value); } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V insert(K key, V value) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) throw new IllegalArgumentException(&quot;Null key&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(newEntry.hash); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketInsertEntry(bucketIndex, newEntry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Gets a key's values from the map and returns the value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// NOTE: returns null if the value is null AND also returns </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// null if the key does not exists, so watch out.. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V get(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; entry = bucketSeekEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry != null) return entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Removes a key from the map and returns the value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// NOTE: returns null if the value is null AND also returns </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// null if the key does not exists. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V remove(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketRemoveEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Removes an entry from a given bucket if it exists </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private V bucketRemoveEntry(int bucketIndex, K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; entry = bucketSeekEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry != null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; links = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;links.remove(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--size; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Inserts an entry in a given bucket only if the entry does not already </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// exist in the given bucket, but if it does then update the entry value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private V bucketInsertEntry(int bucketIndex, Entry &lt;K, V&gt; entry) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) table[bucketIndex] = bucket = new LinkedList&lt;&gt;(); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; existentEntry = bucketSeekEntry(bucketIndex, entry.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (existentEntry == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bucket.add(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (++size &gt; threshold) resizeTable(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; // Use null to indicate that there was no previous entry </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V oldVal = existentEntry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;existentEntry.value = entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return oldVal; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Finds and returns a particular entry in a given bucket if it exists, returns null otherwise </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private Entry &lt;K, V&gt; bucketSeekEntry(int bucketIndex, K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K, V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry.key.equals(key)) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return entry; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Resizes the internal table holding buckets of entries </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private void resizeTable() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;capacity *= 2; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;threshold = (int) (capacity * maxLoadFactor); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K,V&gt;&gt; [] newTable = new LinkedList[capacity]; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; table.length; i++) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (table[i] != null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K, V&gt; entry : table[i]) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(entry.hash); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket = newTable[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) newTable[bucketIndex] = bucket = new LinkedList&lt;&gt;(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bucket.add(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Avoid memory leak. Help the GC </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table[i].clear(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table[i] = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;&#160;&#160; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table = newTable; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the list of keys found within the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public List &lt;K&gt; keys() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;List &lt;K&gt; keys = new ArrayList&lt;&gt;(size()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket : table) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K,V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;keys.add(entry.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;return keys; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the list of values found within the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public List &lt;V&gt; values() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;List &lt;V&gt; values = new ArrayList&lt;&gt;(size()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket : table) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K,V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;values.add(entry.value); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return values; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">} </font>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1567047863123" ID="ID_1180079256" MODIFIED="1567047869247" TEXT="Hash table open addressing">
<node CREATED="1577369532976" ID="ID_1689117443" MODIFIED="1577369540468" TEXT="Collision resolution technique"/>
<node CREATED="1577369543428" ID="ID_200938945" MODIFIED="1577369547331" TEXT="Open addressing basics">
<node CREATED="1577369547601" ID="ID_1618933428" MODIFIED="1577369562797" TEXT="The goal of the Hash Table (HT) is to construct a mapping from keys to values."/>
<node CREATED="1577369565898" ID="ID_1462552710" MODIFIED="1577369580451" TEXT="Keys must be hashable and we need a hash function that converts keys to whole numbers."/>
<node CREATED="1577369580828" ID="ID_1706198356" MODIFIED="1577369598220" TEXT="We use the hash function defined on our key set to index into an array (the hash table)."/>
<node CREATED="1577369598691" ID="ID_1870903960" MODIFIED="1577369643429" TEXT="Hash functions are not perfect, therefore sometimes two keys k1, k2 (k1 != k2) hash to the same value. When this happens we have a hash collision (i.e H(k1 = H(k2))"/>
<node CREATED="1577369644277" ID="ID_1732474554" MODIFIED="1577369650757" TEXT="Open addressing is a way to solve this issue.">
<node CREATED="1577369725675" ID="ID_1006939397" MODIFIED="1577369729212" TEXT="Open addressing basics">
<node CREATED="1577369729829" ID="ID_1357789143" MODIFIED="1577369767421" TEXT="When using open addressing as a collision resolution technique the key-value pairs are stored in teh table (array) itself as opposed to a data structure like in separate chaining."/>
<node CREATED="1577369769214" ID="ID_1933827972" MODIFIED="1577369789661" TEXT="This means we need to care a great deal about the size of our hash table and how many elements are currently in the table">
<node CREATED="1577369790630" ID="ID_783717030" MODIFIED="1577369799174" TEXT="Load factor = items in table / size of table"/>
<node CREATED="1577369848109" ID="ID_78644049" MODIFIED="1577369853668" TEXT="or else difficult to find slot"/>
</node>
</node>
</node>
<node CREATED="1577369884965" ID="ID_245954382" MODIFIED="1577369926941" TEXT="The O(1) constant time behaviour attributed to hash tables ssumes the load factor (alpha) is kept below a certain fixed value. This means once alpha &gt; threshold we need to grow the table size (ideally exponentially, e.g double).">
<node CREATED="1577369948941" ID="ID_1421341182" MODIFIED="1577369959736" TEXT="It may get exponentially bad after certain threshold"/>
</node>
<node CREATED="1577369975963" ID="ID_974261891" MODIFIED="1577369981224" TEXT="Open addressing main idea">
<node CREATED="1577369983373" ID="ID_433586555" MODIFIED="1577370020144" TEXT="When we want to insert a key-value pair (k, v) into the hash table we hash the key and obtain an original position for where this key-value pair belongs, i.e H(k)"/>
<node CREATED="1577370022101" ID="ID_1145833824" MODIFIED="1577370058985" TEXT="If the position our key hashed to is occupied we try another position in the hash table by offsetting the current position subject o a probing sequence P(x). We keep doing this until an unoccupied slot is found."/>
<node CREATED="1577370120313" ID="ID_932454091" MODIFIED="1577370137628" TEXT="There are an infinite amount of probing sequences you can come up with, here are a few:">
<node CREATED="1577370138724" ID="ID_750593367" MODIFIED="1577370157299" TEXT="Linear probing">
<node CREATED="1577370157779" ID="ID_922155410" MODIFIED="1577370169217" TEXT="P(x) = ax + b where a, b are constants"/>
</node>
<node CREATED="1577370171738" ID="ID_1917168744" MODIFIED="1577370176061" TEXT="Quadratic probing">
<node CREATED="1577370176282" ID="ID_44258301" MODIFIED="1577370194942" TEXT="P(x) = ax^2 + bx + c where a, b, c are constants"/>
</node>
<node CREATED="1577370196206" ID="ID_492274658" MODIFIED="1577370199220" TEXT="Double hashing">
<node CREATED="1577370199525" ID="ID_41924921" MODIFIED="1577370220113" TEXT="P(k,x) = x*H2(k), where H2(k) is a secondary hash function"/>
</node>
<node CREATED="1577370221605" ID="ID_1414408699" MODIFIED="1577370230446" TEXT="Pseudo random number generator:">
<node CREATED="1577370230815" ID="ID_344675924" MODIFIED="1577370264202" TEXT="P(k,x) = x * RNG(H(k), x), where RNG is a random number generator function seeded with H(k)">
<node CREATED="1577370342147" ID="ID_460257500" MODIFIED="1577370355235" TEXT="sead is H(k) which is deterministic (same always)">
<node CREATED="1577370377456" ID="ID_1325730476" MODIFIED="1577370383894" TEXT="x increments by 1 each time"/>
</node>
</node>
</node>
</node>
<node CREATED="1577370396111" ID="ID_668632316" MODIFIED="1577370409027" TEXT="General insertion method for open addressing on a table of size N goes as follows:">
<node CREATED="1577370413508" ID="ID_324538868" MODIFIED="1577370505615">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      x := 1
    </p>
    <p>
      keyHash := H(k)
    </p>
    <p>
      index := keyHash
    </p>
    <p>
      
    </p>
    <p>
      while table[index] != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;index = (keyHash + P(k,x)) mod N
    </p>
    <p>
      &#160;&#160;&#160;&#160;x = x + 1
    </p>
    <p>
      
    </p>
    <p>
      insert (k,v) at table[index]
    </p>
    <p>
      
    </p>
    <p>
      Where H(k) is the hash for the key k and P(k,x) is the probing function
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1577370613045" ID="ID_372683697" MODIFIED="1577370616078" TEXT="Chaos with cycles">
<node CREATED="1577370616406" ID="ID_785800868" MODIFIED="1577370635366" TEXT="Most randomly selected probing sequences modulo N will produce a cycle shorter than the table size."/>
<node CREATED="1577370636695" ID="ID_468980738" MODIFIED="1577370661647" TEXT="This becomes problamatic when you are trying to insert a key-value pair and all the buckets on the cycle are occupied because you will get stuck in an infinite loop!">
<node CREATED="1577370714038" ID="ID_48188437" MODIFIED="1577370734183" TEXT="Suppose the sequence produces only 3 slots and cycles through them infinitely">
<node CREATED="1577370748803" ID="ID_582834116" MODIFIED="1577370750674" TEXT="Example:">
<node CREATED="1577370750864" ID="ID_214027381" MODIFIED="1577370791996" TEXT="k1,v1, null, null, k2,v2, k3,v3,k4,v4, null, null, k5,v5, null, k6,v6, null">
<node CREATED="1577370793485" ID="ID_115437890" MODIFIED="1577370807477" TEXT="Assume the probing sequence used is P(x) = 4x"/>
<node CREATED="1577370807837" ID="ID_1577758174" MODIFIED="1577370823814" TEXT="Now suppose we want to insert (k,v) into the table and H(k) = 8">
<node CREATED="1577619298033" ID="ID_398640541" MODIFIED="1577619408682" TEXT="index = H(k) = 8 + 0 mode 12 = 8"/>
<node CREATED="1577619310186" ID="ID_1092679344" MODIFIED="1577619372033" TEXT="index = H(k) + P(1) = 8 + 4 mod 12 = 0"/>
<node CREATED="1577619327318" ID="ID_427905433" MODIFIED="1577619364816" TEXT="index = H(k) + P(2) = 8 + 8 mod 12 = 4"/>
<node CREATED="1577619382448" ID="ID_821101256" MODIFIED="1577619402104" TEXT="index = H(k) + P(3) = 8 + 12 mod 12 = 8"/>
<node CREATED="1577619410482" ID="ID_1492200526" MODIFIED="1577619412274" TEXT="..."/>
</node>
<node CREATED="1577619441330" ID="ID_1927049410" MODIFIED="1577619451265" TEXT="We have a cycle even though there are empty slots"/>
</node>
</node>
<node CREATED="1577619458384" ID="ID_1105828211" MODIFIED="1577619480425" TEXT="Q: So that&apos;s concerning, how do we handle probing functions which produce cycles shorter than the table size?">
<node CREATED="1577619484985" ID="ID_1834393274" MODIFIED="1577619533375" TEXT="A: In general the concesnus is that we don&apos;t handle this issue, instead we avoid it altogether by restricting our domain of probing functions to those which produce a cycle of exactly length N*">
<node CREATED="1577619536883" ID="ID_1433164446" MODIFIED="1577619556246" TEXT="* There are a few exceptions with special proprties that can produce shorter cycles."/>
</node>
</node>
<node CREATED="1577619616414" ID="ID_383019877" MODIFIED="1577619620653" TEXT="Chaos with cycles">
<node CREATED="1577619624190" ID="ID_1674799779" MODIFIED="1577619667581" TEXT="Techniques such as linear probing, quadratic probing and double hashing are all subject to the issue of causing cycles which is why the probing functions used with these methods are very specific. This is a large topic that will be the focus of the next few vidoes."/>
<node CREATED="1577619669391" ID="ID_1618509427" MODIFIED="1577619713511" TEXT="Notice that open addressing is very sensitive to the hashing function and probing function used. This is not something you have to worry about (as much) if you are using separate chaining as a collision resolution method."/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047870330" ID="ID_146250376" MODIFIED="1567047875833" TEXT="Hash table linear probing">
<node CREATED="1577619920151" ID="ID_1851249096" MODIFIED="1577619926308" TEXT="Open addressing main idea">
<node CREATED="1577619926872" ID="ID_1147539272" MODIFIED="1577620008347">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      General insertion method for open addressing on a table of size N goes as follows:
    </p>
    <p>
      
    </p>
    <p>
      x := 1
    </p>
    <p>
      keyHash := H(k)
    </p>
    <p>
      index := keyHash
    </p>
    <p>
      
    </p>
    <p>
      while table[index] != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;index = (keyHash + P(k,x)) mod N
    </p>
    <p>
      &#160;&#160;&#160;&#160;x = x + 1
    </p>
    <p>
      
    </p>
    <p>
      insert (k, v) at table[index]
    </p>
    <p>
      
    </p>
    <p>
      where H(k) is the hash for the key k and P(k,x) is the probing function
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1577620034317" ID="ID_1379463749" MODIFIED="1577620042229" TEXT="What is linear probing (LP)?">
<node CREATED="1577620043130" ID="ID_1332539606" MODIFIED="1577620061852" TEXT="LP is a probing method which probes according to a lnear formula, specifically:">
<node CREATED="1577620062411" ID="ID_1116627164" MODIFIED="1577620099102" TEXT="P(x) = ax + b where a (!=0), be are constants (Note: The constant b is obsolete, do you know why?)">
<node CREATED="1577620129162" ID="ID_1934365427" MODIFIED="1577620158588" TEXT="However, as we previously saw not all linear functions are viable because they are unable to produce a cycle of order N. We will need some way to handle this."/>
</node>
</node>
</node>
<node CREATED="1577620181008" ID="ID_395596916" MODIFIED="1577620249775" TEXT="If our linear function is: P(x) = 3x, H(k) = 4, and table size is nine (N = 9) we end up with the following cycle occurring:g:">
<node CREATED="1577620250046" ID="ID_1916993484" MODIFIED="1577620258598" TEXT="H(k) + P(0) mod N = 4"/>
<node CREATED="1577620258822" ID="ID_1092062" MODIFIED="1577620270234" TEXT="H(k) + P(1) mod N = 7"/>
<node CREATED="1577620270473" ID="ID_55739188" MODIFIED="1577620284757" TEXT="H(k) + P(2) mod N = 1"/>
<node CREATED="1577620285094" ID="ID_1912421457" MODIFIED="1577620297886" TEXT="H(k) + P(3) mod N = 4"/>
<node CREATED="1577620298790" ID="ID_279494917" MODIFIED="1577620299694" TEXT="..."/>
</node>
<node CREATED="1577620337789" ID="ID_148960283" MODIFIED="1577620360735" TEXT="The cycle {4,7,1} makes it impossible to reach buckets {0,2,3,5,6,8}!">
<node CREATED="1577620363639" ID="ID_1583601574" MODIFIED="1577620379047" TEXT="Causing infinite loop in our hash table if all the buckets 4, 7, and 1 were already occupied!"/>
</node>
<node CREATED="1577620418001" ID="ID_1516221096" MODIFIED="1577620436397" TEXT="Q: Which value(s) of the constant a in P(x) = ax produce a full cycle module N??">
<node CREATED="1577620437316" ID="ID_1543377192" MODIFIED="1577620502262" TEXT="A: This happens when a and N are relatively prime. Two numbers are relatively prime if their Greatest Common Denominator (GCD) is equal to one. Hence, when GCD(a,N) = 1 the probing function P(x) be able to generate a complete cycle and we will always be able to find an empty bucket!"/>
</node>
<node CREATED="1577620632341" ID="ID_266375603" MODIFIED="1577620657755" TEXT="Suppose we have an originally empty hash table ans we want to insert some (ki,vi) pairs with LP and we selected our hash table to have:">
<node CREATED="1577620658138" ID="ID_34004819" MODIFIED="1577620671115" TEXT="Probing function: P(x) = 6x"/>
<node CREATED="1577620671356" ID="ID_1393257194" MODIFIED="1577620678034" TEXT="Fixed table size: N = 8"/>
<node CREATED="1577620678963" ID="ID_1677260361" MODIFIED="1577620686891" TEXT="Max load factor: alpha = 0.667"/>
<node CREATED="1577620687668" ID="ID_274216484" MODIFIED="1577620696802" TEXT="Threshold before resize = N * alpha = 6">
<node CREATED="1577620749531" ID="ID_1432589682" MODIFIED="1577620762902" TEXT="GCD(6, 9) = 3 and not 1">
<node CREATED="1577620952802" ID="ID_1036035522" MODIFIED="1577620982944" TEXT="Most likely to cause cycle"/>
</node>
</node>
</node>
<node CREATED="1577621010764" ID="ID_1068529528" MODIFIED="1577621031654" TEXT="A common choice for P(x) is P(x) = 1x since GCD(N, 1) = 1 no matter the choice of N (table size)">
<node CREATED="1577621468823" ID="ID_1541073778" MODIFIED="1577621503175" TEXT="Suppose we have an originally empty hash table and we want to insert some (ki,vi) pairs with LP and we welected our hash table to have:">
<node CREATED="1577621503749" ID="ID_1776369745" MODIFIED="1577621563494">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Probing function: P(x) = 5x
    </p>
    <p>
      Fixed table size: N = 12
    </p>
    <p>
      Max load factor: @ = 0.35
    </p>
    <p>
      Threshold before resize = N * alpha = 4
    </p>
    <p>
      
    </p>
    <p>
      GCD(12, 5) = 1 so no cycle should occur!
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1577621576440" ID="ID_1662673749" MODIFIED="1577621592784" TEXT="H(k1) + P(0) mod 12 = 10"/>
<node CREATED="1577621596789" ID="ID_946609011" MODIFIED="1577621612927" TEXT="H(k2) + P(0) mod 12 = 8"/>
<node CREATED="1577621613182" ID="ID_1753935856" MODIFIED="1577621624074" TEXT="H(k3) + P(1) mod 12 = 3"/>
<node CREATED="1577621626329" ID="ID_1341414478" MODIFIED="1577621651265" TEXT="H(k4) + P(3) mod 12 = 1"/>
<node CREATED="1577621669430" ID="ID_1899446043" MODIFIED="1577621678655" TEXT="threshold = 4">
<node CREATED="1577621681525" ID="ID_380790446" MODIFIED="1577621685989" TEXT="Resizing the table">
<node CREATED="1577621695874" ID="ID_1968764159" MODIFIED="1577621753722" TEXT="Before we insert the next (ki,vi) pair, notice that we have reached the threshold value, so we need to grow the table. Usually this is done in some exponential fashion such as doubling the table size,Whatever you do make sure GCD(N,a) = 1 still holds.">
<node CREATED="1577621848015" ID="ID_771616597" MODIFIED="1577621878275" TEXT="After doubling N = 24 alpha is constant so it&apos;s still 0.35 New threshold value = N * alpha = 8, The probing function P(x) does not change.">
<node CREATED="1577621919175" ID="ID_823893828" MODIFIED="1577621947371" TEXT="Upon allocating memory for a new table we need to insert the contents of the old table into the new table.">
<node CREATED="1577621978457" ID="ID_295068800" MODIFIED="1577621989693" TEXT="scan all positions and re-calculate index and copy"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1577622072499" ID="ID_769535602" MODIFIED="1577622097356" TEXT="Q: Sweet, I know how insertion works, now how do I remove key-value pairs from the hash table using open addressing?">
<node CREATED="1577622103131" ID="ID_1475346986" MODIFIED="1577622116771" TEXT="A: This topic by itself mertis its own video (link in the description)."/>
</node>
</node>
</node>
<node CREATED="1567047877084" ID="ID_1344116679" MODIFIED="1567047883639" TEXT="Hash table quadratic probing">
<node CREATED="1577633773588" ID="ID_1117252357" MODIFIED="1577633779864" TEXT="What is quadratic probing?">
<node CREATED="1577633780979" ID="ID_1930003366" MODIFIED="1577633797071" TEXT="QP is a probing method which probes according to a quadratic formula, specifically:">
<node CREATED="1577633797512" ID="ID_372367502" MODIFIED="1577633835920" TEXT="P(x) = ax^2 + bx + c where a,b,c are constants and a != 0 (otherwise we have linear probing) (Note: The constant c is obsolete, do you know why?)">
<node CREATED="1577635255432" ID="ID_1590497890" MODIFIED="1577635286822" TEXT="However, as we previously saw not all quadratic functions are viable because they are unable to produce a cycle of order N. We will need some way to handle this."/>
</node>
</node>
<node CREATED="1577635922948" ID="ID_706060464" MODIFIED="1577635927247" TEXT="Chaos with Cycles">
<node CREATED="1577635928335" ID="ID_1814808605" MODIFIED="1577635979306" TEXT="Randomly selected QP functions have the issue that they easily produce short cycles. For example, if P(x) = 2x^2 + 2, H(k) = 4, and table size is nine (N  9) we end up with the following cycle occurring:">
<node CREATED="1577635981280" ID="ID_1961313944" MODIFIED="1577635990408" TEXT="H(k) + P(0) mod N = 4"/>
<node CREATED="1577636000427" ID="ID_1022512573" MODIFIED="1577636008442" TEXT="H(k) + P(1) mod N = 7"/>
<node CREATED="1577636009870" ID="ID_1697740604" MODIFIED="1577636018130" TEXT="H(k) + P(2) mod N = 4"/>
<node CREATED="1577636018880" ID="ID_1385709185" MODIFIED="1577636027322" TEXT="H(k) + P(3) mod N = 7"/>
<node CREATED="1577636027897" ID="ID_1063380178" MODIFIED="1577636035051" TEXT="H(k) + P(4) mod N = 4"/>
<node CREATED="1577636035428" ID="ID_1191560945" MODIFIED="1577636042715" TEXT="H(k) + P(5) mod N = 7"/>
</node>
<node CREATED="1577636046489" ID="ID_1436287773" MODIFIED="1577636073427" TEXT="The cycle {4,7} makes it impossible to reach buckets {0,1,2,3,5,6,8}!"/>
<node CREATED="1577636074362" ID="ID_77422493" MODIFIED="1577636091899" TEXT="This would cause an infinite loop in our hash table if the buckets 4 and 7 were already occupied!">
<node CREATED="1577805164590" ID="ID_1585309245" MODIFIED="1577805189405" TEXT="Q: So how do we pick a probing function we can work with?">
<node CREATED="1577805193924" ID="ID_1455074623" MODIFIED="1577805223081" TEXT="merous ways, but thA: There are numerous ways but three of the most popular approaches are:">
<node CREATED="1577805223282" ID="ID_244432597" MODIFIED="1577805241191" TEXT="Let P(x) = x^2, keep the table size a prime number &gt; 3 and also keep alpha &lt;= 1/2"/>
<node CREATED="1577805243588" ID="ID_1067704977" MODIFIED="1577805260872" TEXT="Let P(x) = (x^2 + x) / 2 and keep the table size a power of two">
<node CREATED="1577805369449" ID="ID_385033137" MODIFIED="1577805377903" TEXT="Let&apos;s see an example">
<node CREATED="1577805397684" ID="ID_1545194148" MODIFIED="1577805424711" TEXT="Suppose we have an originall empty hash table ans we want to insert some (ki, vi) pairs with QP and we selected our hash table to have:">
<node CREATED="1577805429249" ID="ID_708331423" MODIFIED="1577805442197" TEXT="Probing function: P(x) = (x^2 + x) / 2"/>
<node CREATED="1577805443827" ID="ID_552971233" MODIFIED="1577805457657" TEXT="Table size: N = 2^3 = 8 (power of two)"/>
<node CREATED="1577805458301" ID="ID_349573618" MODIFIED="1577805467455" TEXT="Max load factor: alpha = 0.4"/>
<node CREATED="1577805468191" ID="ID_938194267" MODIFIED="1577805491734" TEXT="Threshold before resize = N * alpha = 3"/>
</node>
</node>
</node>
<node CREATED="1577805261156" ID="ID_65098880" MODIFIED="1577805287294" TEXT="Let P(x) = (-1^x)*x^2 and keep the table size a prime N where N = 3 mod 4"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047884522" ID="ID_1596198472" MODIFIED="1567047889979" TEXT="Hash table double hashing"/>
<node CREATED="1567047890930" ID="ID_422156043" MODIFIED="1567047899043" TEXT="Hash table removing key-value pairs"/>
<node CREATED="1567047903541" ID="ID_1761414486" MODIFIED="1567047910266" TEXT="Hash table open addressing source code"/>
</node>
<node CREATED="1567047916017" ID="ID_1895167146" MODIFIED="1567047925223" POSITION="left" TEXT="Fenwick tree/ Binary indexed tree">
<node CREATED="1567047926501" ID="ID_1669705925" MODIFIED="1567047932949" TEXT="Fenwick tree range queries"/>
<node CREATED="1567047934157" ID="ID_1668128613" MODIFIED="1567047940049" TEXT="Fenwick tree point updates"/>
<node CREATED="1567047940961" ID="ID_814720894" MODIFIED="1567047946570" TEXT="Fenwick tree construction"/>
<node CREATED="1567047947928" ID="ID_210618531" MODIFIED="1567047952477" TEXT="Fenwick tree source code"/>
</node>
<node CREATED="1567047959209" ID="ID_1666717418" MODIFIED="1567047961852" POSITION="right" TEXT="AVL Tree">
<node CREATED="1567047962620" ID="ID_1999519162" MODIFIED="1567047965491" TEXT="Tree rotations"/>
<node CREATED="1567047966997" ID="ID_1916570050" MODIFIED="1567047973404" TEXT="AVL tree insertions"/>
<node CREATED="1567047975034" ID="ID_994624740" MODIFIED="1567047980588" TEXT="AVL tree removals"/>
<node CREATED="1567047981371" ID="ID_76219402" MODIFIED="1567047986021" TEXT="AVL tree source code"/>
</node>
<node CREATED="1567047990936" ID="ID_430826137" MODIFIED="1567047995764" POSITION="left" TEXT="Indexed Priority Queue">
<node CREATED="1567047996676" ID="ID_1465373898" MODIFIED="1567048021205" TEXT="Introduction to indexed priority queues"/>
<node CREATED="1567048022793" ID="ID_526212390" MODIFIED="1567048028448" TEXT="Indexed priority queue source code"/>
</node>
</node>
</map>
