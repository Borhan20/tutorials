{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12600\viewh14060\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Kube-Scheduler
\b0  (https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/)\
1. For each newly created pod or any un-scheduled pod, Kube-scheduler selects an optimal node for the pod to run\
2. The node has to meet scheduling requirements of the pod (called feasible nodes)\
	1. Factors used for decision\
		1. Resource requirements (hardware say - 2 GB RAM, 2 CPUs, \'85)\
3. If there are multiple feasible nodes, scheduler scores them and picks a node with highest score\
	1. If nodes have equal rank\
		1. One of them is chosen arbitrarily\
4. Scheduler notifies API server about the decision\
5. If there are no feasible nodes available for the pod, it remains unscheduled (in the queue)\
\

\b Kube-Proxy
\b0 \
1. \
\

\b Kube-Controller-Manager
\b0 \
1. It is a control-loop that watches shared state of cluster through API-Server and makes changes attempting to move current state towards desired state.\
	1. It is a non-terminating loop\
2. Example:\
	1. Replication controller - controls number of replicas in a pod\
	2. \'85\
\

\b Kubelet
\b0 \
1. Runs on each node (worker machine)\
2. It takes new or modified pod specifications (through Kube API-Server primarily) & ensures the the pods and their containers are healthy and running in desired state\
3. It also reports health of the host to master\
\

\b Kubectl
\b0 \
1. Command-line tool that communicates with Kube API-Server\
2. It sends commands to master node\
	1. Each command is converted to API call}