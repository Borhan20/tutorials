# Software Construction #
## Readings ##
### Static Checking ###
#### Types ####
#### Static Checking vs Dynamic Checking ####
#### Arrays and Collections ####
#### Iterating ####
#### Methods ####
#### Mutating Variables vs Reassigning Variables ####
#### Documenting Assumptions ####

### Basic Java ###
#### Snapshot Diagrams ####
#### Java Collections ####
#### Java API Documentation ####

### Testing ###
1. Safe from bugs
	1. correct today and in unknown future
2. Easy to understand
	1. Communication clearly with future programmers (including future you)
3. Ready for change

#### Validation ####
#### Test-first Programming ####
#### Choosing Test Cases by Partitioning ####
#### Blackbox and Whitebox Testing ####
#### Documenting Testing Strategies ####
#### Coverage ####
#### Unit Testing and Stubs ####
#### Automated Testing and Regression Testing ####

### Code Review ###
#### Don't Repeat Yourself ####
#### Comments Where Needed ####
#### Fail Fast ####
#### Avoid Magic Numbers ####
#### One Purpose for Each Variable ####
#### Use Good Names ####
#### Use Whitespace to Help the Reader ####
#### Don't Use Global Variables ####
#### Methods Should Return Results, Not Print Them ####

### Version Control ###
#### Inventing Version Control ####
#### Git: Copy, Commit, Pull, Push, Merge ####

### Specifications ###
#### Why Specifications? ####
#### Behavioral Equivalence ####
#### Specification Structure ####
#### Null References ####
#### What a Specification May Talk About ####
#### Testing and Specifications ####
#### Specifications for Mutating Methods ####
#### Exceptions for SIgnaling Bugs ####
#### Exceptions for Special Results ####
#### Checked and Unchecked Exceptions ####
#### Throwable Hierarchy ####
#### Exception Design Considerations ####
#### Abuse of Exceptions ####

### Designing Specifications ###
#### Deterministic vs Undetermined Specs ####
#### Declarative vs Operational Specs ####
#### Stronger vs Weaker Specs ####
#### Diagramming Specifications ####
#### Designing Good Specifications ####
#### Precondition or Postcondition? ####
#### About Access Control ####
#### About Static vs Instance Methods ####

### Avoiding Debugging ###
#### First Defense: Making Bugs Impossible ####
#### Second Defense: Localizing Bugs ####
#### Assertions ####
#### What to Assert ####
#### What Not to Assert ####
#### Incremental Development ####
#### Modularity and Encapsulation ####

### Mutability & Immutability ###
#### Mutability ####
#### Risks of Mutation ####
#### Aliasing is What Makes Mutation Risky ####
#### Specifications for Mutating Methods ####
#### Iterating Over Arrays and Lists ####
#### Mutation Undermines an Iterator ####
#### Mutation and Contracts ####
#### Useful Implementation Types ####

### Recursion ###
### Debugging ###
### Abstract Data Types ###
### Abstraction Functions & Rep Invariants ###
### Interfaces ###
### Equality ###
### Recursive Data Types ###
### Regular Data Types ###
### Parser Generators ###
### Concurrency ###
### Thread Safety ###
### Sockets & Networking ###
### Queues & Message-Passing ###
### Locks & Synchronization ###
### Graphical User Interfaces ###
### Map, Filter, Reduce ###
### Little Languages ###
### Team Version Control ###

## General ##
### General Information ###
### Collaboration and Public Sharing ###
### Code Reviewing ###
### Nanoquiz Grading and Makeups ###

## Getting Started ##
### Getting Started: Java, Eclipse & Git ###
### Getting Started: Java ###
### Getting Started: Eclipse FAQ ###

## Problem Sets ##
### Turtle Graphics ###
### Tweet Tweet ###
### Poetic Walks ###
### Expressivo ###
### Multiplayer Minesweeper ###

## Project ##
### ABC Music Player ###

## Quizzes ##
### Quiz 1 and Quiz 1 solutions ###
### Quiz 2 and Quiz 2 solutions ###
### Quiz Archive ###